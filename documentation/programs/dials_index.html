
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dials.index &mdash; DIALS  documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/dials-styles.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/dials_icon.png"/>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="DIALS  documentation" href="../../index.html" />
    <link rel="up" title="Program documentation" href="index.html" />
    <link rel="next" title="dials.refine_bravais_settings" href="dials_refine_bravais_settings.html" />
    <link rel="prev" title="dials.find_spots" href="dials_find_spots.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  <div class="logoheader container">
  <a href="../../index.html">
  <img class="logoheader" alt="DIALS" src="../../_static/dials_header.png" />
  </a>
  </div>
  



  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="dials-index">
<h1>dials.index<a class="headerlink" href="#dials-index" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This program attempts to perform autoindexing on strong spots output by the
program dials.find_spots. The program is called with a &#8220;datablock.json&#8221; file
(as generated by dials.import) and a &#8220;strong.pickle&#8221; file (as generated by
dials.find_spots). If one or more lattices are identified given the input
list of strong spots, then the crystal orientation and experimental geometry
are refined to minimise the differences between the observed and predicted
spot centroids. The program will output an &#8220;experiments.json&#8221; file which
is similar to the input &#8220;datablock.json&#8221; file, but with the addition of the
crystal model(s), and an &#8220;indexed.pickle&#8221; file which is similar to the input
&#8220;strong.pickle&#8221; file, but with the addition of miller indices and predicted
spot centroids.</p>
<p>dials.index provides both one-dimensional and three-dimensional fast Fourier
transform (FFT) based methods. These can be chosen by setting the parameters
indexing.method=fft1d or indexing.method=fft3d. By default the program searches
for a primitive lattice, and then proceeds with refinement in space group P1.
If the unit_cell and space_group parameters are set, then the program will
only accept solutions which are consistent with these parameters. Space group
constraints will be enforced in refinement as appropriate.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span class="n">dials</span><span class="o">.</span><span class="n">index</span> <span class="n">datablock</span><span class="o">.</span><span class="n">json</span> <span class="n">strong</span><span class="o">.</span><span class="n">pickle</span>

<span class="n">dials</span><span class="o">.</span><span class="n">index</span> <span class="n">datablock</span><span class="o">.</span><span class="n">json</span> <span class="n">strong</span><span class="o">.</span><span class="n">pickle</span> <span class="n">unit_cell</span><span class="o">=</span><span class="mi">37</span><span class="p">,</span><span class="mi">79</span><span class="p">,</span><span class="mi">79</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span> <span class="n">space_group</span><span class="o">=</span><span class="n">P43212</span>

<span class="n">dials</span><span class="o">.</span><span class="n">index</span> <span class="n">datablock</span><span class="o">.</span><span class="n">json</span> <span class="n">strong</span><span class="o">.</span><span class="n">pickle</span> <span class="n">indexing</span><span class="o">.</span><span class="n">method</span><span class="o">=</span><span class="n">fft1d</span>
</pre></div>
</div>
</div>
<div class="section" id="basic-parameters">
<h2>Basic parameters<a class="headerlink" href="#basic-parameters" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">
indexing {
  nproc = 1
  fft3d {
    reciprocal_space_grid {
      d_min = Auto
    }
  }
  scan_range = None
  known_symmetry {
    space_group = None
    unit_cell = None
  }
  index_assignment {
    simple {
      hkl_tolerance = 0.3
    }
  }
  check_misindexing {
    grid_search_scope = 0
  }
  refinement_protocol {
    n_macro_cycles = Auto
    d_min_step = Auto
    d_min_start = None
    d_min_final = None
    verbosity = 1
  }
  method = *fft3d fft1d real_space_grid_search
  stills {
    ewald_proximity_resolution_cutoff = 2.0
    refine_all_candidates = True
    rmsd_min_px = 2
    ewald_proximal_volume_max = 0.0025
    isoforms {
      name = None
      cell = None
      lookup_symbol = None
      rmsd_target_mm = None
      beam_restraint = None
    }
  }
}
refinement {
  verbosity = 0
  parameterisation {
    auto_reduction {
      min_nref_per_parameter = 5
      action = *fail fix remove
    }
    scan_varying = False
    beam {
      fix = all *in_spindle_plane out_spindle_plane *wavelength
    }
    crystal {
      fix = all cell orientation
    }
    detector {
      fix = all position orientation
    }
    goniometer {
      fix = *all in_beam_plane out_beam_plane
    }
  }
  reflections {
    reflections_per_degree = 100
    minimum_sample_size = 1000
    maximum_sample_size = None
    outlier {
      algorithm = null *auto mcd tukey sauter_poon
      minimum_number_of_reflections = 20
      separate_experiments = True
      separate_panels = Auto
      separate_blocks = True
      block_width = Auto
    }
  }
}
output {
  experiments = experiments.json
  split_experiments = False
  reflections = indexed.pickle
  unindexed_reflections = None
  log = dials.index.log
  debug_log = dials.index.debug.log
}
verbosity = 1

</pre>
</div>
<div class="section" id="full-parameter-definitions">
<h2>Full parameter definitions<a class="headerlink" href="#full-parameter-definitions" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">
indexing {
  nproc = 1
    .help = &quot;The number of processes to use.&quot;
    .type = int(value_min=1)
  mm_search_scope = 4.0
    .help = &quot;Global radius of origin offset search.&quot;
    .type = float(value_min=0)
    .expert_level = 1
  wide_search_binning = 2
    .help = &quot;Modify the coarseness of the wide grid search for the beam&quot;
            &quot;centre.&quot;
    .type = float(value_min=0)
    .expert_level = 1
  min_cell_volume = 25
    .help = &quot;Minimum unit cell volume (in Angstrom^3).&quot;
    .type = float(value_min=0)
    .expert_level = 1
  min_cell = 3
    .help = &quot;Minimum length of candidate unit cell basis vectors (in&quot;
            &quot;Angstrom).&quot;
    .type = float(value_min=0)
    .expert_level = 1
  max_cell = Auto
    .help = &quot;Maximum length of candidate unit cell basis vectors (in&quot;
            &quot;Angstrom).&quot;
    .type = float(value_min=0)
    .expert_level = 1
  max_cell_estimation
    .expert_level = 1
  {
    filter_ice = True
      .help = &quot;Filter out reflections at typical ice ring resolutions before&quot;
              &quot;max_cell estimation.&quot;
      .type = bool
    filter_overlaps = True
      .help = &quot;Filter out reflections with overlapping bounding boxes before&quot;
              &quot;max_cell estimation.&quot;
      .type = bool
    overlaps_border = 0
      .help = &quot;Optionally add a border around the bounding boxes before&quot;
              &quot;finding overlaps.&quot;
      .type = int(value_min=0)
    multiplier = 1.3
      .help = &quot;Multiply the estimated maximum basis vector length by this&quot;
              &quot;value.&quot;
      .type = float(value_min=0)
      .expert_level = 2
    step_size = 45
      .help = &quot;Step size, in degrees, of the blocks used to peform the&quot;
              &quot;max_cell  estimation.&quot;
      .type = float(value_min=0)
      .expert_level = 2
    nearest_neighbor_percentile = None
      .help = &quot;Percentile of NN histogram to use for max cell determination.&quot;
      .type = float(value_min=0, value_max=1)
      .expert_level = 2
    histogram_binning = linear *log
      .help = &quot;Choose between linear or logarithmic bins for nearest neighbour&quot;
              &quot;histogram analysis.&quot;
      .type = choice
    nn_per_bin = 5
      .help = &quot;Target number of nearest neighbours per histogram bin.&quot;
      .type = int(value_min=1)
    max_height_fraction = 0.25
      .type = float(value_min=0, value_max=1)
      .expert_level = 2
  }
  fft3d {
    peak_search = *flood_fill clean
      .type = choice
      .expert_level = 2
    peak_volume_cutoff = 0.15
      .type = float
      .expert_level = 2
    reciprocal_space_grid {
      n_points = 256
        .type = int(value_min=0)
        .expert_level = 1
      d_min = Auto
        .help = &quot;The high resolution limit in Angstrom for spots to include in&quot;
                &quot; the initial indexing.&quot;
        .type = float(value_min=0)
    }
  }
  sigma_phi_deg = None
    .help = &quot;Override the phi sigmas for refinement. Mainly intended for&quot;
            &quot;single-shot rotation images where the phi sigma is almost&quot;
            &quot;certainly incorrect.&quot;
    .type = float(value_min=0)
    .expert_level = 2
  b_iso = Auto
    .type = float(value_min=0)
    .expert_level = 2
  rmsd_cutoff = 15
    .type = float(value_min=0)
    .expert_level = 1
  scan_range = None
    .help = &quot;The range of images to use in indexing. Number of arguments must&quot;
            &quot;be a factor of two. Specifying  0 0&quot; will use all images&quot; by&quot;
            &quot;default. The given range follows C conventions (e.g. j0 &lt;= j &lt;&quot;
            &quot;j1).&quot;
    .type = ints(size=2)
    .multiple = True
  known_symmetry {
    space_group = None
      .help = &quot;Target space group for indexing.&quot;
      .type = space_group
    unit_cell = None
      .help = &quot;Target unit cell for indexing.&quot;
      .type = unit_cell
    relative_length_tolerance = 0.1
      .help = &quot;Relative tolerance for unit cell lengths in unit cell&quot;
              &quot;comparision.&quot;
      .type = float
      .expert_level = 1
    absolute_angle_tolerance = 5
      .help = &quot;Angular tolerance (in degrees) in unit cell comparison.&quot;
      .type = float
      .expert_level = 1
    max_delta = 5
      .help = &quot;Maximum allowed Le Page delta used in searching for basis&quot;
              &quot;vector combinations that are consistent with the given&quot;
              &quot;symmetry.&quot;
      .type = float(value_min=0)
      .expert_level = 1
  }
  basis_vector_combinations
    .expert_level = 1
  {
    max_combinations = None
      .help = &quot;Maximum number of basis vector combinations to test for&quot;
              &quot;agreement with input symmetry.&quot;
      .type = int(value_min=1)
    max_refine = Auto
      .help = &quot;Maximum number of putative crystal models to test. Default for&quot;
              &quot;rotation sweeps: 50, for still images: 5&quot;
      .type = int(value_min=1)
      .expert_level = 1
    sys_absent_threshold = 0.9
      .type = float(value_min=0, value_max=1)
    solution_scorer = filter *weighted
      .type = choice
      .expert_level = 1
    filter
      .expert_level = 1
    {
      check_doubled_cell = True
        .type = bool
      likelihood_cutoff = 0.8
        .type = float(value_min=0, value_max=1)
      volume_cutoff = 1.25
        .type = float(value_min=1)
      n_indexed_cutoff = 0.9
        .type = float(value_min=0, value_max=1)
    }
    weighted
      .expert_level = 1
    {
      power = 1
        .type = int(value_min=1)
      volume_weight = 1
        .type = float(value_min=0)
      n_indexed_weight = 1
        .type = float(value_min=0)
      rmsd_weight = 1
        .type = float(value_min=0)
    }
  }
  index_assignment {
    method = *simple local
      .help = &quot;Choose between simple 'global' index assignment and xds-style &quot;
              &quot;'local' index assignment.&quot;
      .type = choice
      .expert_level = 1
    simple {
      hkl_tolerance = 0.3
        .help = &quot;Maximum allowable deviation from integer-ness for assigning &quot;
                &quot;a miller index to a reciprocal lattice vector.&quot;
        .type = float(value_min=0, value_max=0.5)
    }
    local
      .expert_level = 1
    {
      epsilon = 0.05
        .help = &quot;This corresponds to the xds parameter INDEX_ERROR=&quot;
        .type = float
      delta = 8
        .help = &quot;This corresponds to the xds parameter INDEX_MAGNITUDE=&quot;
        .type = int
      l_min = 0.8
        .help = &quot;This corresponds to the xds parameter INDEX_QUALITY=&quot;
        .type = float
      nearest_neighbours = 20
        .type = int(value_min=1)
    }
  }
  check_misindexing {
    grid_search_scope = 0
      .help = &quot;Search scope for testing misindexing on h, k, l.&quot;
      .type = int
  }
  optimise_initial_basis_vectors = False
    .type = bool
    .expert_level = 2
  debug = False
    .type = bool
    .expert_level = 1
  debug_plots = False
    .help = &quot;Requires matplotlib&quot;
    .type = bool
    .expert_level = 1
  combine_scans = False
    .type = bool
    .expert_level = 1
  refinement_protocol {
    mode = *refine_shells repredict_only
      .help = &quot;refine_shells: refine in increasing resolution cutoffs after&quot;
              &quot;indexing. repredict_only: do not refine after indexing, just&quot;
              &quot;update spot predictions.&quot;
      .type = choice
      .expert_level = 1
    n_macro_cycles = Auto
      .type = int(value_min=1)
    d_min_step = Auto
      .help = &quot;Reduction per step in d_min for reflections to include in&quot;
              &quot;refinement.&quot;
      .type = float(value_min=0)
    d_min_start = None
      .type = float(value_min=0)
    d_min_final = None
      .help = &quot;Do not ever include reflections below this value in refinement.&quot;
      .type = float(value_min=0)
    verbosity = 1
      .type = int(value_min=0)
    disable_unit_cell_volume_sanity_check = False
      .help = &quot;Disable sanity check on unrealistic increases in unit cell&quot;
              &quot;volume during refinement.&quot;
      .type = bool
      .expert_level = 1
  }
  method = *fft3d fft1d real_space_grid_search
    .type = choice
  multiple_lattice_search
    .expert_level = 1
  {
    cluster_analysis_search = False
      .help = &quot;Perform cluster analysis search for multiple lattices.&quot;
      .type = bool
    recycle_unindexed_reflections_cutoff = 0.1
      .help = &quot;Attempt another cycle of indexing on the unindexed reflections &quot;
              &quot;if more than the fraction of input reflections are unindexed.&quot;
      .type = float(value_min=0, value_max=1)
    minimum_angular_separation = 5
      .help = &quot;The minimum angular separation (in degrees) between two&quot;
              &quot;lattices.&quot;
      .type = float(value_min=0)
    max_lattices = 1
      .type = int
    cluster_analysis {
      method = *dbscan hcluster
        .type = choice
      hcluster {
        linkage {
          method = *ward
            .type = choice
          metric = *euclidean
            .type = choice
        }
        cutoff = 15
          .type = float(value_min=0)
        cutoff_criterion = *distance inconsistent
          .type = choice
      }
      dbscan {
        eps = 0.05
          .type = float(value_min=0)
        min_samples = 30
          .type = int(value_min=1)
      }
      min_cluster_size = 20
        .type = int(value_min=0)
      intersection_union_ratio_cutoff = 0.4
        .type = float(value_min=0, value_max=1)
    }
  }
  real_space_grid_search
    .expert_level = 1
  {
    characteristic_grid = 0.02
      .type = float(value_min=0)
  }
  stills {
    indexer = *Auto stills sweeps
      .help = &quot;Use the stills or sweeps indexer. Auto: choose based on the&quot;
              &quot;input imagesets (stills or sweeps).&quot;
      .type = choice
      .expert_level = 1
    ewald_proximity_resolution_cutoff = 2.0
      .help = &quot;the acceptable volume of reciprocal space for spot prediction&quot;
      .type = float
    refine_all_candidates = True
      .help = &quot;If False, no attempt is made to refine the model from initial&quot;
              &quot;basis vector selection. The indexing solution with the best&quot;
              &quot;RMSD is chosen.&quot;
      .type = bool
    candidate_outlier_rejection = True
      .help = &quot;If True, while refining candiate basis solutions, also apply&quot;
              &quot;Sauter/ Poon (2010) outlier rejection&quot;
      .type = bool
      .expert_level = 1
    refine_candidates_with_known_symmetry = False
      .help = &quot;If False, when choosing the best set of candidate basis&quot;
              &quot;solutions, refine the candidates in the P1 setting. If True,&quot;
              &quot;after indexing in P1, convert the candidates to the known&quot;
              &quot;symmetry and apply the corresponding change of basis to the&quot;
              &quot;indexed reflections.&quot;
      .type = bool
      .expert_level = 2
    rmsd_min_px = 2
      .help = &quot;Minimum acceptable RMSD for choosing candidate basis solutions&quot;
              &quot;(in pixels)&quot;
      .type = float
    ewald_proximal_volume_max = 0.0025
      .help = &quot;Maximum acceptable ewald proximal volume when choosing&quot;
              &quot;candidate basis solutions&quot;
      .type = float
    isoforms
      .help = &quot;Constrain the unit cell to specific values during refinement&quot;
              &quot;after initial indexing.&quot;
      .multiple = True
    {
      name = None
        .type = str
      cell = None
        .type = unit_cell
      lookup_symbol = None
        .help = &quot;The sgtbx lookup symbol of the reflections pointgroup&quot;
        .type = str
      rmsd_target_mm = None
        .help = &quot;Maximum acceptable DIALS positional rmsd, in mm&quot;
        .type = float
      beam_restraint = None
        .help = &quot;to assure that no images are accepted where the lattice is&quot;
                &quot;misindexed by a unit shift.&quot;
        .type = floats(size=2)
    }
  }
}
refinement
  .help = &quot;Parameters to configure the refinement&quot;
{
  mp
    .expert_level = 2
  {
    nproc = 1
      .help = &quot;The number of processes to use. Not all choices of refinement&quot;
              &quot;engine support nproc &gt; 1. Where multiprocessing is possible, it&quot;
              &quot;is helpful only in certain circumstances, so this is not&quot;
              &quot;recommended for typical use.&quot;
      .type = int(value_min=1)
  }
  verbosity = 0
    .help = &quot;verbosity level&quot;
    .type = int(value_min=0)
  parameterisation
    .help = &quot;Parameters to control the parameterisation of experimental models&quot;
  {
    auto_reduction
      .help = &quot;determine behaviour when there are too few reflections to&quot;
              &quot;reasonably produce a full parameterisation of the experiment&quot;
              &quot;list&quot;
    {
      min_nref_per_parameter = 5
        .help = &quot;the smallest number of reflections per parameter for a model&quot;
                &quot;parameterisation below which the parameterisation will not be&quot;
                &quot;made in full, but the action described below will be&quot;
                &quot;triggered.&quot;
        .type = int(value_min=1)
      action = *fail fix remove
        .help = &quot;action to take if there are too few reflections across the&quot;
                &quot;experiments related to a particular model parameterisation.&quot;
                &quot;If fail, an exception will be raised and refinement will not&quot;
                &quot;proceed. If fix, refinement will continue but with the&quot;
                &quot;parameters relating to that model remaining fixed at their&quot;
                &quot;initial values. If remove, parameters relating to that model&quot;
                &quot;will be fixed, and in addition all reflections related to&quot;
                &quot;that parameterisation will be removed. This will therefore&quot;
                &quot;remove this reflections from other parameterisations of the&quot;
                &quot;global model too. For example, if a crystal model could not&quot;
                &quot;be parameterised it will be excised completely and not&quot;
                &quot;contribute to the joint refinement of the detector and beam.&quot;
                &quot;In the fix mode, reflections emanating from that crystal will&quot;
                &quot;still form residuals and will contribute to detector and beam&quot;
                &quot;refinement.&quot;
        .type = choice
      detector_reduce = False
        .help = &quot;Special case designed for detector metrology refinement&quot;
                &quot;(particularly of the CSPAD). See detector_reduce_list for&quot;
                &quot;details.&quot;
        .type = bool
        .expert_level = 1
      detector_reduce_list = Dist Tau2 Tau3
        .help = &quot;Partial names to match to detector parameters to try fixing.&quot;
                &quot;If there are still not enough parameters for refinement after&quot;
                &quot;fixing these, then fail. This is to ensure that metrology&quot;
                &quot;refinement never completes if it is not able to refine some&quot;
                &quot;panels. The default is to try fixing the distance as well as&quot;
                &quot;Tau2 and Tau3 rotations of detector panel, leaving the&quot;
                &quot;in-plane shifts and the rotation around the detector normal&quot;
                &quot;for refinement. groups only.&quot;
        .type = strings
        .expert_level = 1
    }
    scan_varying = False
      .help = &quot;Allow models that are not forced to be static to vary during&quot;
              &quot;the
               scan&quot;
      .type = bool
    compose_model_per = image *block
      .help = &quot;For scan-varying parameterisations, compose a new model either&quot;
              &quot;every image or within blocks of a width specified in the&quot;
              &quot;reflections parameters. When this block width is larger than&quot;
              &quot;the image width the result is faster, with a trade-off in&quot;
              &quot;accuracy&quot;
      .type = choice
      .expert_level = 1
    debug_centroid_analysis = False
      .help = &quot;Set True to write out a file containing the reflections used&quot;
              &quot;for centroid analysis for automatic setting of the &quot;
              &quot;scan-varying interval width. This can then be analysed with&quot;
              &quot;dev.dials.plot_centroid_analysis&quot;
      .type = bool
      .expert_level = 2
    beam
      .help = &quot;beam parameters&quot;
    {
      fix = all *in_spindle_plane out_spindle_plane *wavelength
        .help = &quot;Whether to fix beam parameters. By default, in_spindle_plane&quot;
                &quot;is selected, and one of the two parameters is fixed. If a&quot;
                &quot;goniometer is present this leads to the beam orientation&quot;
                &quot;being restricted to a direction in the initial spindle-beam&quot;
                &quot;plane. Wavelength is also fixed by default, to allow&quot;
                &quot;refinement of the unit cell volume.&quot;
        .type = choice(multi=True)
      fix_list = None
        .help = &quot;Fix specified parameters by a list of 0-based indices or&quot;
                &quot;partial names to match&quot;
        .type = strings
        .expert_level = 1
      constraints
        .help = &quot;Parameter equal shift constraints to use in refinement.&quot;
        .multiple = True
        .expert_level = 2
      {
        id = None
          .help = &quot;Select only the specified experiments when looking up which&quot;
                  &quot;parameterisations to apply the constraint to. If an&quot;
                  &quot;identified parameterisation affects multiple experiments&quot;
                  &quot;then the index of any one of those experiments suffices to&quot;
                  &quot;identify that parameterisation. If None (the default) then&quot;
                  &quot;constraints will be applied to all parameterisations of&quot;
                  &quot;this type.&quot;
          .type = ints(value_min=0)
        parameter = None
          .help = &quot;Identify which parameter of each parameterisation to&quot;
                  &quot;constrain by a (partial) parameter name to match. Model&quot;
                  &quot;name prefixes such as 'Detector1' will be ignored as&quot;
                  &quot;parameterisations are already identified by experiment id&quot;
          .type = str
      }
      force_static = True
        .help = &quot;Force a static parameterisation for the beam when doing&quot;
                &quot;scan-varying refinement&quot;
        .type = bool
        .expert_level = 1
      smoother
        .help = &quot;Options that affect scan-varying parameterisation&quot;
        .expert_level = 1
      {
        interval_width_degrees = 36.0
          .help = &quot;Width of scan between checkpoints in degrees. Can be set to&quot;
                  &quot;Auto.&quot;
          .type = float(value_min=0)
        absolute_num_intervals = None
          .help = &quot;Number of intervals between checkpoints if scan_varying&quot;
                  &quot;refinement is requested. If set, this overrides&quot;
                  &quot;interval_width_degrees&quot;
          .type = int(value_min=1)
      }
    }
    crystal
      .help = &quot;crystal parameters&quot;
    {
      fix = all cell orientation
        .help = &quot;Fix crystal parameters&quot;
        .type = choice
      unit_cell
        .expert_level = 1
      {
        fix_list = None
          .help = &quot;Fix specified parameters by a list of 0-based indices or&quot;
                  &quot;partial names to match&quot;
          .type = strings
          .expert_level = 1
        restraints
          .help = &quot;Least squares unit cell restraints to use in refinement.&quot;
          .expert_level = 1
        {
          tie_to_target
            .multiple = True
          {
            values = None
              .help = &quot;Target unit cell parameters for the restraint for this&quot;
                      &quot;parameterisation&quot;
              .type = floats(size=6)
            sigmas = None
              .help = &quot;The unit cell target values are associated with sigmas&quot;
                      &quot;which are used to determine the weight of each&quot;
                      &quot;restraint. A sigma of zero will remove the restraint at&quot;
                      &quot;that position. If symmetry constrains two cell&quot;
                      &quot;dimensions to be equal then only the smaller of the two&quot;
                      &quot;sigmas will be kept&quot;
              .type = floats(size=6, value_min=0)
            id = None
              .help = &quot;Select only the specified experiments when looking up&quot;
                      &quot;which parameterisations to apply these restraints to.&quot;
                      &quot;If an identified parameterisation affects multiple&quot;
                      &quot;experiments then the index of any one of those&quot;
                      &quot;experiments suffices to restrain that parameterisation.&quot;
                      &quot;If None (the default) then the restraints will be&quot;
                      &quot;applied to all experiments.&quot;
              .type = ints(value_min=0)
          }
          tie_to_group
            .multiple = True
          {
            target = *mean low_memory_mean median
              .help = &quot;Function to tie group parameter values to&quot;
              .type = choice
            sigmas = None
              .help = &quot;The unit cell parameters are associated with sigmas&quot;
                      &quot;which are used to determine the weight of each&quot;
                      &quot;restraint. A sigma of zero will remove the restraint at&quot;
                      &quot;that position.&quot;
              .type = floats(size=6, value_min=0)
            id = None
              .help = &quot;Select only the specified experiments when looking up&quot;
                      &quot;which  parameterisations to apply these restraints to.&quot;
                      &quot;For every parameterisation that requires a restraint at&quot;
                      &quot;least one experiment index must be supplied. If None&quot;
                      &quot;(the default) the restraints will be applied to all&quot;
                      &quot;experiments.&quot;
              .type = ints(value_min=0)
          }
        }
        constraints
          .help = &quot;Parameter equal shift constraints to use in refinement.&quot;
          .multiple = True
          .expert_level = 2
        {
          id = None
            .help = &quot;Select only the specified experiments when looking up&quot;
                    &quot;which parameterisations to apply the constraint to. If an&quot;
                    &quot;identified parameterisation affects multiple experiments&quot;
                    &quot;then the index of any one of those experiments suffices&quot;
                    &quot;to identify that parameterisation. If None (the default)&quot;
                    &quot;then constraints will be applied to all parameterisations&quot;
                    &quot;of this type.&quot;
            .type = ints(value_min=0)
          parameter = None
            .help = &quot;Identify which parameter of each parameterisation to&quot;
                    &quot;constrain by a (partial) parameter name to match. Model&quot;
                    &quot;name prefixes such as 'Detector1' will be ignored as&quot;
                    &quot;parameterisations are already identified by experiment id&quot;
            .type = str
        }
        force_static = False
          .help = &quot;Force a static parameterisation for the crystal unit cell&quot;
                  &quot;when doing scan-varying refinement&quot;
          .type = bool
          .expert_level = 1
        smoother
          .help = &quot;Options that affect scan-varying parameterisation&quot;
          .expert_level = 1
        {
          interval_width_degrees = 36.0
            .help = &quot;Width of scan between checkpoints in degrees. Can be set&quot;
                    &quot;to Auto.&quot;
            .type = float(value_min=0)
          absolute_num_intervals = None
            .help = &quot;Number of intervals between checkpoints if scan_varying&quot;
                    &quot;refinement is requested. If set, this overrides&quot;
                    &quot;interval_width_degrees&quot;
            .type = int(value_min=1)
        }
      }
      orientation
        .expert_level = 1
      {
        fix_list = None
          .help = &quot;Fix specified parameters by a list of 0-based indices or&quot;
                  &quot;partial names to match&quot;
          .type = strings
          .expert_level = 1
        constraints
          .help = &quot;Parameter equal shift constraints to use in refinement.&quot;
          .multiple = True
          .expert_level = 2
        {
          id = None
            .help = &quot;Select only the specified experiments when looking up&quot;
                    &quot;which parameterisations to apply the constraint to. If an&quot;
                    &quot;identified parameterisation affects multiple experiments&quot;
                    &quot;then the index of any one of those experiments suffices&quot;
                    &quot;to identify that parameterisation. If None (the default)&quot;
                    &quot;then constraints will be applied to all parameterisations&quot;
                    &quot;of this type.&quot;
            .type = ints(value_min=0)
          parameter = None
            .help = &quot;Identify which parameter of each parameterisation to&quot;
                    &quot;constrain by a (partial) parameter name to match. Model&quot;
                    &quot;name prefixes such as 'Detector1' will be ignored as&quot;
                    &quot;parameterisations are already identified by experiment id&quot;
            .type = str
        }
        force_static = False
          .help = &quot;Force a static parameterisation for the crystal orientation&quot;
                  &quot;when doing scan-varying refinement&quot;
          .type = bool
          .expert_level = 1
        smoother
          .help = &quot;Options that affect scan-varying parameterisation&quot;
          .expert_level = 1
        {
          interval_width_degrees = 36.0
            .help = &quot;Width of scan between checkpoints in degrees. Can be set&quot;
                    &quot;to Auto.&quot;
            .type = float(value_min=0)
          absolute_num_intervals = None
            .help = &quot;Number of intervals between checkpoints if scan_varying&quot;
                    &quot;refinement is requested. If set, this overrides&quot;
                    &quot;interval_width_degrees&quot;
            .type = int(value_min=1)
        }
      }
    }
    detector
      .help = &quot;detector parameters&quot;
    {
      panels = *automatic single multiple hierarchical
        .help = &quot;Select appropriate detector parameterisation. Both the single&quot;
                &quot;and multiple panel detector options treat the whole detector&quot;
                &quot;as a rigid body. The hierarchical parameterisation treats&quot;
                &quot;groups of panels as separate rigid bodies.&quot;
        .type = choice
        .expert_level = 1
      hierarchy_level = 0
        .help = &quot;Level of the detector hierarchy (starting from the root at 0)&quot;
                &quot;at which to determine panel groups to parameterise&quot;
                &quot;independently&quot;
        .type = int(value_min=0)
        .expert_level = 1
      fix = all position orientation
        .help = &quot;Fix detector parameters. The translational parameters&quot;
                &quot;(position) may be set separately to the orientation.&quot;
        .type = choice
      fix_list = None
        .help = &quot;Fix specified parameters by a list of 0-based indices or&quot;
                &quot;partial names to match&quot;
        .type = strings
        .expert_level = 1
      constraints
        .help = &quot;Parameter equal shift constraints to use in refinement.&quot;
        .multiple = True
        .expert_level = 2
      {
        id = None
          .help = &quot;Select only the specified experiments when looking up which&quot;
                  &quot;parameterisations to apply the constraint to. If an&quot;
                  &quot;identified parameterisation affects multiple experiments&quot;
                  &quot;then the index of any one of those experiments suffices to&quot;
                  &quot;identify that parameterisation. If None (the default) then&quot;
                  &quot;constraints will be applied to all parameterisations of&quot;
                  &quot;this type.&quot;
          .type = ints(value_min=0)
        parameter = None
          .help = &quot;Identify which parameter of each parameterisation to&quot;
                  &quot;constrain by a (partial) parameter name to match. Model&quot;
                  &quot;name prefixes such as 'Detector1' will be ignored as&quot;
                  &quot;parameterisations are already identified by experiment id&quot;
          .type = str
      }
      force_static = True
        .help = &quot;Force a static parameterisation for the detector when doing&quot;
                &quot;scan-varying refinement&quot;
        .type = bool
        .expert_level = 1
      smoother
        .help = &quot;Options that affect scan-varying parameterisation&quot;
        .expert_level = 1
      {
        interval_width_degrees = 36.0
          .help = &quot;Width of scan between checkpoints in degrees. Can be set to&quot;
                  &quot;Auto.&quot;
          .type = float(value_min=0)
        absolute_num_intervals = None
          .help = &quot;Number of intervals between checkpoints if scan_varying&quot;
                  &quot;refinement is requested. If set, this overrides&quot;
                  &quot;interval_width_degrees&quot;
          .type = int(value_min=1)
      }
    }
    goniometer
      .help = &quot;goniometer setting matrix parameters&quot;
    {
      fix = *all in_beam_plane out_beam_plane
        .help = &quot;Whether to fix goniometer parameters. By default, fix all.&quot;
                &quot;Alternatively the setting matrix can be constrained to allow&quot;
                &quot;rotation only within the spindle-beam plane or to allow&quot;
                &quot;rotation only around an axis that lies in that plane. Set to&quot;
                &quot;None to refine the in two orthogonal directions.&quot;
        .type = choice(multi=True)
      fix_list = None
        .help = &quot;Fix specified parameters by a list of 0-based indices or&quot;
                &quot;partial names to match&quot;
        .type = strings
        .expert_level = 1
      constraints
        .help = &quot;Parameter equal shift constraints to use in refinement.&quot;
        .multiple = True
        .expert_level = 2
      {
        id = None
          .help = &quot;Select only the specified experiments when looking up which&quot;
                  &quot;parameterisations to apply the constraint to. If an&quot;
                  &quot;identified parameterisation affects multiple experiments&quot;
                  &quot;then the index of any one of those experiments suffices to&quot;
                  &quot;identify that parameterisation. If None (the default) then&quot;
                  &quot;constraints will be applied to all parameterisations of&quot;
                  &quot;this type.&quot;
          .type = ints(value_min=0)
        parameter = None
          .help = &quot;Identify which parameter of each parameterisation to&quot;
                  &quot;constrain by a (partial) parameter name to match. Model&quot;
                  &quot;name prefixes such as 'Detector1' will be ignored as&quot;
                  &quot;parameterisations are already identified by experiment id&quot;
          .type = str
      }
      force_static = True
        .help = &quot;Force a static parameterisation for the goniometer when doing&quot;
                &quot;scan-varying refinement&quot;
        .type = bool
        .expert_level = 1
      smoother
        .help = &quot;Options that affect scan-varying parameterisation&quot;
        .expert_level = 1
      {
        interval_width_degrees = 36.0
          .help = &quot;Width of scan between checkpoints in degrees. Can be set to&quot;
                  &quot;Auto.&quot;
          .type = float(value_min=0)
        absolute_num_intervals = None
          .help = &quot;Number of intervals between checkpoints if scan_varying&quot;
                  &quot;refinement is requested. If set, this overrides&quot;
                  &quot;interval_width_degrees&quot;
          .type = int(value_min=1)
      }
    }
    sparse = Auto
      .help = &quot;Calculate gradients using sparse data structures.&quot;
      .type = bool
      .expert_level = 1
    treat_single_image_as_still = False
      .help = &quot;Set this to True to treat a single image scan with a non zero&quot;
              &quot;oscillation width as a still&quot;
      .type = bool
      .expert_level = 1
    spherical_relp_model = False
      .help = &quot;For stills refinement, set true to use the spherical relp model&quot;
              &quot;for prediction and gradients.&quot;
      .type = bool
      .expert_level = 1
  }
  refinery
    .help = &quot;Parameters to configure the refinery&quot;
    .expert_level = 1
  {
    engine = SimpleLBFGS LBFGScurvs GaussNewton *LevMar SparseLevMar
      .help = &quot;The minimisation engine to use&quot;
      .type = choice
    max_iterations = None
      .help = &quot;Maximum number of iterations in refinement before termination.&quot;
              &quot;None implies the engine supplies its own default.&quot;
      .type = int(value_min=1)
    log = None
      .help = &quot;Filename for an optional log that a minimisation engine may use&quot;
              &quot;to write additional information&quot;
      .type = path
    journal
      .help = &quot;Extra items to track in the refinement history&quot;
    {
      track_step = False
        .help = &quot;Record parameter shifts history in the refinement journal, if&quot;
                &quot;the engine supports it.&quot;
        .type = bool
      track_gradient = False
        .help = &quot;Record parameter gradients history in the refinement journal,&quot;
                &quot;if the engine supports it.&quot;
        .type = bool
      track_parameter_correlation = False
        .help = &quot;Record correlation matrix between columns of the Jacobian for&quot;
                &quot;each step of refinement.&quot;
        .type = bool
      track_condition_number = False
        .help = &quot;Record condition number of the Jacobian for each step of &quot;
                &quot;refinement.&quot;
        .type = bool
      track_out_of_sample_rmsd = False
        .help = &quot;Record RMSDs calculated using the refined experiments with&quot;
                &quot;reflections not used in refinement at each step. Only valid&quot;
                &quot;if a subset of input reflections was taken for refinement&quot;
        .type = bool
    }
  }
  target
    .help = &quot;Parameters to configure the target function&quot;
    .expert_level = 1
  {
    rmsd_cutoff = *fraction_of_bin_size absolute
      .help = &quot;Method to choose rmsd cutoffs. This is currently either as a&quot;
              &quot;fraction of the discrete units of the spot positional data,&quot;
              &quot;i.e. (pixel width, pixel height, image thickness in phi), or a&quot;
              &quot;tuple of absolute values to use as the cutoffs&quot;
      .type = choice
    bin_size_fraction = 0.0
      .help = &quot;Set this to a fractional value, say 0.2, to make a cut off in&quot;
              &quot;the natural discrete units of positional data, viz., (pixel&quot;
              &quot;width, pixel height, image thickness in phi). This would then&quot;
              &quot;determine when the RMSD target is achieved. Only used if&quot;
              &quot;rmsd_cutoff = fraction_of_bin_size.&quot;
      .type = float(value_min=0)
    absolute_cutoffs = None
      .help = &quot;Absolute Values for the RMSD target achieved cutoffs in X, Y&quot;
              &quot;and Phi. The units are (mm, mm, rad).&quot;
      .type = floats(size=3, value_min=0)
    gradient_calculation_blocksize = None
      .help = &quot;Maximum number of reflections to use for gradient calculation.&quot;
              &quot;If there are more reflections than this in the manager then the&quot;
              &quot;minimiser must do the full calculation in blocks.&quot;
      .type = int(value_min=1)
  }
  reflections
    .help = &quot;Parameters used by the reflection manager&quot;
  {
    reflections_per_degree = 100
      .help = &quot;The number of centroids per degree of the sweep to use in&quot;
              &quot;refinement. Set to None to use all suitable reflections.&quot;
      .type = float(value_min=0)
    minimum_sample_size = 1000
      .help = &quot;cutoff that determines whether subsetting of the input&quot;
              &quot;reflection list is done&quot;
      .type = int
    maximum_sample_size = None
      .help = &quot;The maximum number of reflections to use in refinement.&quot;
              &quot;Overrides reflections_per_degree if that produces a larger&quot;
              &quot;sample size.&quot;
      .type = int(value_min=1)
    random_seed = 42
      .help = &quot;Random seed to use when sampling to create a working set of&quot;
              &quot;reflections. May be int or None.&quot;
      .type = int
      .expert_level = 1
    close_to_spindle_cutoff = 0.02
      .help = &quot;The inclusion criterion currently uses the volume of the&quot;
              &quot;parallelepiped formed by the spindle axis, the incident beam&quot;
              &quot;and the scattered beam. If this is lower than some value then&quot;
              &quot;the reflection is excluded from refinement. In detector space,&quot;
              &quot;these are the reflections located close to the rotation axis.&quot;
      .type = float(value_min=0)
      .expert_level = 1
    block_width = 1.0
      .help = &quot;Width of a reflection 'block' (in degrees) determining how&quot;
              &quot;fine- grained the model used for scan-varying prediction during&quot;
              &quot;refinement is. Currently only has any effect if the crystal&quot;
              &quot;parameterisation is set to use compose_model_per=block&quot;
      .type = float(value_min=0)
      .expert_level = 1
    weighting_strategy
      .help = &quot;Parameters to configure weighting strategy overrides&quot;
      .expert_level = 1
    {
      override = statistical stills constant external_deltapsi
        .help = &quot;selection of a strategy to override default weighting&quot;
                &quot;behaviour&quot;
        .type = choice
      delpsi_constant = 1000000
        .help = &quot;used by the stills strategy to choose absolute weight value&quot;
                &quot;for the angular distance from Ewald sphere term of the target&quot;
                &quot;function, whilst the X and Y parts use statistical weights&quot;
        .type = float(value_min=0)
      constants = 1.0 1.0 1.0
        .help = &quot;constant weights for three parts of the target function,&quot;
                &quot;whether the case is for stills or scans. The default gives&quot;
                &quot;unit weighting.&quot;
        .type = floats(size=3, value_min=0)
    }
    outlier
      .help = &quot;Outlier rejection after initial reflection prediction.&quot;
    {
      algorithm = null *auto mcd tukey sauter_poon
        .help = &quot;Outlier rejection algorithm. If auto is selected, the&quot;
                &quot;algorithm is chosen automatically&quot;
        .type = choice
      minimum_number_of_reflections = 20
        .help = &quot;The minimum number of input observations per outlier&quot;
                &quot;rejection job below which all reflections in the job will be&quot;
                &quot;rejected as potential outliers.&quot;
        .type = int(value_min=0)
      separate_experiments = True
        .help = &quot;If true, outlier rejection will be performed on each&quot;
                &quot;experiment separately. Otherwise, the data from all&quot;
                &quot;experiments will be combined for outlier rejection.&quot;
        .type = bool
      separate_panels = Auto
        .help = &quot;If true, outlier rejection will be performed separately for&quot;
                &quot;each panel of a multi-panel detector model. Otherwise data&quot;
                &quot;from across all panels will be combined for outlier&quot;
                &quot;rejection.&quot;
        .type = bool
      separate_blocks = True
        .help = &quot;If true, for scans outlier rejection will be performed&quot;
                &quot;separately in equal-width blocks of phi, controlled by the&quot;
                &quot;parameter outlier.block_width.&quot;
        .type = bool
      block_width = Auto
        .help = &quot;If separate_blocks, a scan will be divided into equal-sized&quot;
                &quot;blocks with width (in degrees) close to this value for&quot;
                &quot;outlier rejection. If Auto, a width of at least 18 degrees&quot;
                &quot;will be determined, such that each block contains enough&quot;
                &quot;reflections to perform outlier rejection.&quot;
        .type = float(value_min=1)
      tukey
        .help = &quot;Options for the tukey outlier rejector&quot;
        .expert_level = 1
      {
        iqr_multiplier = 1.5
          .help = &quot;The IQR multiplier used to detect outliers. A value of 1.5&quot;
                  &quot;gives Tukey's rule for outlier detection&quot;
          .type = float(value_min=0)
      }
      mcd
        .help = &quot;Options for the mcd outlier rejector, which uses an algorithm&quot;
                &quot;based on FAST-MCD by Rousseeuw and van Driessen. See&quot;
                &quot;doi.org/10.1080/00401706.1999.10485670.&quot;
        .expert_level = 1
      {
        alpha = 0.5
          .help = &quot;Decimal fraction controlling the size of subsets over which&quot;
                  &quot;the covariance matrix determinant is minimised.&quot;
          .type = float(value_min=0, value_max=1)
        max_n_groups = 5
          .help = &quot;The maximum number of groups to split the dataset into if&quot;
                  &quot;the dataset is 'large' (more observations than twice the&quot;
                  &quot;min_group_size).&quot;
          .type = int(value_min=1)
        min_group_size = 300
          .help = &quot;The smallest sub-dataset size when splitting the dataset&quot;
                  &quot;into a number of groups, maximally max_n_groups.&quot;
          .type = int(value_min=100)
        n_trials = 500
          .help = &quot;The number of samples used for initial estimates to seed&quot;
                  &quot;the search within each sub-dataset.&quot;
          .type = int(value_min=1)
        k1 = 2
          .help = &quot;The number of concentration steps to take after initial&quot;
                  &quot;estimates.&quot;
          .type = int(value_min=1)
        k2 = 2
          .help = &quot;If the dataset is 'large', the number of concentration&quot;
                  &quot;steps to take after applying the best subset estimates to&quot;
                  &quot;the merged group.&quot;
          .type = int(value_min=1)
        k3 = 100
          .help = &quot;If the dataset is 'small', the number of concentration&quot;
                  &quot;steps to take after selecting the best of the initial&quot;
                  &quot;estimates, applied to the whole dataset.&quot;
          .type = int(value_min=1)
        threshold_probability = 0.975
          .help = &quot;Quantile probability from the Chi-squared distribution with&quot;
                  &quot;number of degrees of freedom equal to the number of&quot;
                  &quot;dimensions of the data data (e.g. 3 for X, Y and Phi&quot;
                  &quot;residuals). Observations whose robust Mahalanobis distances&quot;
                  &quot;are larger than the obtained quantile will be flagged as&quot;
                  &quot;outliers.&quot;
          .type = float(value_min=0, value_max=1)
      }
      sauter_poon
        .help = &quot;Options for the outlier rejector described in Sauter &amp; Poon&quot;
                &quot;(2010) (<a class="reference external" href="http://dx.doi.org/10.1107/S0021889810010782">http://dx.doi.org/10.1107/S0021889810010782</a>)&quot;
        .expert_level = 1
      {
        px_sz = Auto
          .help = &quot;X, Y pixel size in mm. If Auto, this will be taken from the&quot;
                  &quot;first panel of the first experiment.&quot;
          .type = floats(size=2, value_min=0.001)
        verbose = False
          .help = &quot;Verbose output.&quot;
          .type = bool
          .multiple = False
        pdf = None
          .help = &quot;Output file name for making graphs of <a href="#id1"><span class="problematic" id="id2">|dr|</span></a> vs spot number&quot;
                  &quot;and dy vs dx.&quot;
          .type = str
          .multiple = False
      }
    }
  }
}
output {
  experiments = experiments.json
    .type = path
  split_experiments = False
    .type = bool
  reflections = indexed.pickle
    .type = path
  unindexed_reflections = None
    .type = path
  log = dials.index.log
    .type = str
  debug_log = dials.index.debug.log
    .type = str
}
verbosity = 1
  .help = &quot;The verbosity level&quot;
  .type = int(value_min=0)

</pre>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><!--<h3>Navigation</h3>-->
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../howto.html">How-to</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../workshops.html">Workshops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../links.html">Links</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer container">
  <a href="http://www.diamond.ac.uk/"><img class="logofooter" alt="Diamond" src="../../_static/diamond_logo.png" /></a>
  <a href="http://www.ccp4.ac.uk/"><img class="logofooter" alt="CCP4" src="../../_static/CCP4-logo-plain.png" /></a>
  <a href="http://www.lbl.gov/"><img class="logofooter" alt="LBL" src="../../_static/LBL-logo-wide.jpeg" /></a>
  <a href="https://www.stfc.ac.uk/"><img class="logofooter" alt="STFC" src="../../_static/STFC_logo.png" /></a>
  </div>

  <script type="text/javascript">
     $(document).ready(function() {
         $(".toggle > *").hide();
         $(".toggle .header").show();
         $(".toggle .header").click(function() {
             $(this).parent().children().not(".header").toggle(400);
             $(this).parent().children(".header").toggleClass("open");
         })
     });
  </script>
  
    <div class="footer">
      &copy;2017, Diamond Light Source, Lawrence Berkeley National Laboratory and STFC.
      
    </div>

    

    

  </body>
</html>