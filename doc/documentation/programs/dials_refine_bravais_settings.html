
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dials.refine_bravais_settings &mdash; DIALS  documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/dials-styles.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/dials_icon.png"/>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="DIALS  documentation" href="../../index.html" />
    <link rel="up" title="Program documentation" href="index.html" />
    <link rel="next" title="dials.reindex" href="dials_reindex.html" />
    <link rel="prev" title="dials.index" href="dials_index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body>
  <div class="logoheader container">
  <a href="../../index.html">
  <img class="logoheader" alt="DIALS" src="../../_static/dials_header.png" />
  </a>
  </div>
  


  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="dials-refine-bravais-settings">
<h1>dials.refine_bravais_settings<a class="headerlink" href="#dials-refine-bravais-settings" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This program takes as input the output of dials.index, i.e. experiments.json
and indexed.pickle files. Full refinement of the crystal and experimental
geometry parameters will be performed (by default) in all Bravais settings
that are consistent with the input primitive unit cell. A table is printed
containing various information for each potential Bravais setting, including
the metric fit (a measure of the deviation from the triclinic cell),
the root-mean-square-deviations (rmsd), in mm, between the observed and
predicted spot centroids, the refined unit cell parameters in each Bravais
setting, and the change of basis operator to transform from the triclinic cell
to each Bravais setting.</p>
<p>The program also generates a .json file for each Bravais setting, e.g.
bravais_setting_1.json, which is equivalent to the input experiments.json, but
with the crystal model refined in the chosen Bravais setting. These
bravais_setting_*.json files are suitable as input to dials.refine or
dials.integrate, although the indexed.pickle file will need to be re-indexed
using dials.reindex if the change of basis operator (cb_op) for the chosen
Bravais setting is not the identity operator (a,b,c).</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre>dials.refine_bravais_settings experiments.json indexed.pickle

dials.refine_bravais_settings experiments.json indexed.pickle nproc=4
</pre></div>
</div>
</div>
<div class="section" id="basic-parameters">
<h2>Basic parameters<a class="headerlink" href="#basic-parameters" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">
lepage_max_delta = 5
verbosity = 0
nproc = Auto
experiment_id = None
refinement {
  verbosity = 1
  parameterisation {
    beam {
      fix = all *in_spindle_plane out_spindle_plane *wavelength
    }
    crystal {
      fix = all cell orientation
      scan_varying = False
    }
    detector {
      fix = all position orientation
    }
  }
  reflections {
    reflections_per_degree = 50
    minimum_sample_size = 1000
    maximum_sample_size = None
    use_all_reflections = False
    minimum_number_of_reflections = 20
    outlier {
      algorithm = *null tukey
    }
  }
}

</pre>
</div>
<div class="section" id="full-parameter-definitions">
<h2>Full parameter definitions<a class="headerlink" href="#full-parameter-definitions" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">
lepage_max_delta = 5
  .type = float
verbosity = 0
  .type = int(value_min=0)
nproc = Auto
  .type = int(value_min=1)
experiment_id = None
  .type = int(value_min=0)
refinement
  .help = &quot;Parameters to configure the refinement&quot;
{
  mp
    .expert_level = 1
  {
    nproc = 1
      .help = &quot;The number of processes to use. Only applicable to certain&quot;
              &quot;choices of refinement engine!&quot;
      .type = int(value_min=1)
  }
  verbosity = 1
    .help = &quot;verbosity level&quot;
    .type = int(value_min=0)
  parameterisation
    .help = &quot;Parameters to control the parameterisation of experimental models&quot;
  {
    beam
      .help = &quot;beam parameters&quot;
    {
      fix = all *in_spindle_plane out_spindle_plane *wavelength
        .help = &quot;Whether to fix beam parameters. By default, in_spindle_plane&quot;
                &quot;is selected, and one of the two parameters is fixed. If a&quot;
                &quot;goniometer is present this leads to the beam orientation&quot;
                &quot;being restricted to a direction in the initial spindle-beam&quot;
                &quot;plane. Wavelength is also fixed by default, to allow&quot;
                &quot;refinement of the unit cell volume.&quot;
        .type = choice(multi=True)
      fix_list = None
        .help = &quot;Fix specified parameters by a list of indices&quot;
        .type = ints(value_min=0)
        .expert_level = 1
    }
    crystal
      .help = &quot;crystal parameters&quot;
    {
      fix = all cell orientation
        .help = &quot;Fix crystal parameters&quot;
        .type = choice
      cell_fix_list = None
        .help = &quot;Fix specified parameters by a list of indices&quot;
        .type = ints(value_min=0)
        .expert_level = 1
      orientation_fix_list = None
        .help = &quot;Fix specified parameters by a list of indices&quot;
        .type = ints(value_min=0)
        .expert_level = 1
      scan_varying = False
        .help = &quot;Parameterise the crystal to vary during the scan&quot;
        .type = bool
      num_intervals = *fixed_width absolute
        .help = &quot;Choose the way to determine the number of intervals for scan-&quot;
                &quot;varying refinement&quot;
        .type = choice
        .expert_level = 1
      interval_width_degrees = 36.0
        .help = &quot;Width of scan between checkpoints in degrees&quot;
        .type = float(value_min=0)
        .expert_level = 1
      absolute_num_intervals = 5
        .help = &quot;Number of intervals between checkpoints if scan_varying&quot;
                &quot;refinement is requested&quot;
        .type = int(value_min=1)
        .expert_level = 1
      UB_model_per = reflection image *block
        .help = &quot;Compose a new crystal model either every reflection (slow),&quot;
                &quot;every image (faster, less accurate) or within blocks of a&quot;
                &quot;width specified in the reflections parameters. When this&quot;
                &quot;block width is larger than the image width the result is&quot;
                &quot;faster again, with another trade-off in accuracy&quot;
        .type = choice
        .expert_level = 1
    }
    detector
      .help = &quot;detector parameters&quot;
    {
      panels = *automatic single multiple hierarchical
        .help = &quot;Select appropriate detector parameterisation. Both the single&quot;
                &quot;and multiple panel detector options treat the whole detector&quot;
                &quot;as a rigid body. The hierarchical parameterisation treats&quot;
                &quot;groups of panels as separate rigid bodies.&quot;
        .type = choice
        .expert_level = 1
      hierarchy_level = 0
        .help = &quot;Level of the detector hierarchy (starting from the root at 0)&quot;
                &quot;at which to determine panel groups to parameterise&quot;
                &quot;independently&quot;
        .type = int(value_min=0)
        .expert_level = 1
      fix = all position orientation
        .help = &quot;Fix detector parameters. The translational parameters&quot;
                &quot;(position) may be set separately to the orientation.&quot;
        .type = choice
      fix_list = None
        .help = &quot;Fix specified parameters by a list of indices&quot;
        .type = ints(value_min=0)
        .expert_level = 1
    }
    sparse = Auto
      .help = &quot;Calculate gradients using sparse data structures.&quot;
      .type = bool
      .expert_level = 1
    treat_single_image_as_still = False
      .help = &quot;Set this to True to treat a single image scan with a non zero&quot;
              &quot;oscillation width as a still&quot;
      .type = bool
      .expert_level = 1
  }
  refinery
    .help = &quot;Parameters to configure the refinery&quot;
    .expert_level = 1
  {
    engine = SimpleLBFGS LBFGScurvs GaussNewton *LevMar
      .help = &quot;The minimisation engine to use&quot;
      .type = choice
    track_step = False
      .help = &quot;Record parameter shifts history in the refinement journal, if&quot;
              &quot;the engine supports it.&quot;
      .type = bool
    track_gradient = False
      .help = &quot;Record parameter gradients history in the refinement journal,&quot;
              &quot;if the engine supports it.&quot;
      .type = bool
    track_parameter_correlation = False
      .help = &quot;Record correlation matrix between columns of the Jacobian for&quot;
              &quot;each step of refinement.&quot;
      .type = bool
    track_out_of_sample_rmsd = False
      .help = &quot;Record RMSDs calculated using the refined experiments with&quot;
              &quot;reflections not used in refinement at each step. Only valid if&quot;
              &quot;a subset of input reflections was taken for refinement&quot;
      .type = bool
    log = None
      .help = &quot;Filename for an optional log that a minimisation engine may use&quot;
              &quot;to write additional information&quot;
      .type = path
    max_iterations = None
      .help = &quot;Maximum number of iterations in refinement before termination.&quot;
              &quot;None implies the engine supplies its own default.&quot;
      .type = int(value_min=1)
  }
  target
    .help = &quot;Parameters to configure the target function&quot;
    .expert_level = 1
  {
    rmsd_cutoff = *fraction_of_bin_size absolute
      .help = &quot;Method to choose rmsd cutoffs. This is currently either as a&quot;
              &quot;fraction of the discrete units of the spot positional data,&quot;
              &quot;i.e. (pixel width, pixel height, image thickness in phi), or a&quot;
              &quot;tuple of absolute values to use as the cutoffs&quot;
      .type = choice
    bin_size_fraction = 0.2
      .help = &quot;Cut off in the natural discrete units of positional data, viz.,&quot;
              &quot;(pixel width, pixel height, image thickness in phi) to use to&quot;
              &quot;determine when the RMSD target is achieved. Only used if&quot;
              &quot;rmsd_cutoff = fraction_of_bin_size.&quot;
      .type = float(value_min=0)
    absolute_cutoffs = None
      .help = &quot;Absolute Values for the RMSD target achieved cutoffs in X, Y&quot;
              &quot;and Phi. The units are (mm, mm, rad).&quot;
      .type = floats(size=3, value_min=0)
    gradient_calculation_blocksize = None
      .help = &quot;Maximum number of reflections to use for gradient calculation.&quot;
              &quot;If there are more reflections than this in the manager then the&quot;
              &quot;minimiser must do the full calculation in blocks.&quot;
      .type = int(value_min=1)
  }
  reflections
    .help = &quot;Parameters used by the reflection manager&quot;
  {
    reflections_per_degree = 50
      .help = &quot;The number of centroids per degree of the sweep to use in&quot;
              &quot;refinement.&quot;
      .type = float(value_min=0)
    minimum_sample_size = 1000
      .help = &quot;cutoff that determines whether subsetting of the input&quot;
              &quot;reflection list is done&quot;
      .type = int
    maximum_sample_size = None
      .help = &quot;The maximum number of reflections to use in refinement.&quot;
              &quot;Overrides reflections_per_degree if that produces a larger&quot;
              &quot;sample size.&quot;
      .type = int(value_min=1)
    use_all_reflections = False
      .help = &quot;Override reflections_per_degree and use all available centroids&quot;
              &quot;in refinement.&quot;
      .type = bool
    random_seed = 42
      .help = &quot;Random seed to use when sampling to create a working set of&quot;
              &quot;reflections. May be int or None.&quot;
      .type = int
      .expert_level = 1
    minimum_number_of_reflections = 20
      .help = &quot;The minimum number of input observations per experiment below&quot;
              &quot;which a reflection manager will not be constructed. This number&quot;
              &quot;is also used to determine the minimum number of reflections per&quot;
              &quot;panel to allow perform outlier rejection to be performed. Below&quot;
              &quot;this, all reflections on the panel are rejected as potential&quot;
              &quot;outliers&quot;
      .type = int(value_min=0)
    close_to_spindle_cutoff = 0.05
      .help = &quot;The inclusion criterion currently uses the volume of the&quot;
              &quot;parallelepiped formed by the spindle axis, the incident beam&quot;
              &quot;and the scattered beam. If this is lower than some value then&quot;
              &quot;the reflection is excluded from refinement. In detector space,&quot;
              &quot;these are the reflections located close to the rotation axis.&quot;
      .type = float(value_min=0)
      .expert_level = 1
    outlier
      .help = &quot;Outlier rejection after initial reflection prediction.&quot;
    {
      algorithm = *null tukey
        .help = &quot;Outlier rejection algorithm&quot;
        .type = choice
      tukey
        .help = &quot;Options for the tukey outlier rejector&quot;
        .expert_level = 1
      {
        iqr_multiplier = 1.5
          .help = &quot;The IQR multiplier used to detect outliers. A value of 1.5&quot;
                  &quot;gives Tukey's rule for outlier detection&quot;
          .type = float(value_min=0)
      }
    }
    block_width = 1.0
      .help = &quot;Width of a reflection 'block' (in degrees) determining how&quot;
              &quot;fine- grained the model used for scan-varying prediction during&quot;
              &quot;refinement is. Currently only has any effect if the crystal&quot;
              &quot;parameterisation is set to use UB_model_per=block&quot;
      .type = float(value_min=0)
      .expert_level = 1
    weighting_strategy
      .help = &quot;Parameters to configure weighting strategy overrides&quot;
      .expert_level = 1
    {
      override = statistical stills constant
        .help = &quot;selection of a strategy to override default weighting&quot;
                &quot;behaviour&quot;
        .type = choice
      delpsi_constant = 10000
        .help = &quot;used by the stills strategy to choose absolute weight value&quot;
                &quot;for the angular distance from Ewald sphere term of the target&quot;
                &quot;function, whilst the X and Y parts use statistical weights&quot;
        .type = float(value_min=0)
      constants = 1.0 1.0 1.0
        .help = &quot;constant weights for three parts of the target function,&quot;
                &quot;whether the case is for stills or scans. The default gives&quot;
                &quot;unit weighting.&quot;
        .type = floats(size=3, value_min=0)
    }
  }
}

</pre>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">DIALS</a></h1>



<p class="blurb">Data Integration for Advanced Light Sources</p>




<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../links.html">Links</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer container">
  <a href="http://www.diamond.ac.uk/"><img class="logofooter" alt="Diamond" src="../../_static/diamond_logo.png" /></a>
  <a href="http://www.ccp4.ac.uk/"><img class="logofooter" alt="CCP4" src="../../_static/CCP4-logo-plain.png" /></a>
  <a href="http://www.lbl.gov/"><img class="logofooter" alt="LBL" src="../../_static/LBL-logo-wide.jpeg" /></a>
  <a href="https://www.stfc.ac.uk/"><img class="logofooter" alt="STFC" src="../../_static/STFC_logo.png" /></a>
  </div>
  
    <div class="footer">
      &copy;2015, Diamond Light Source, Lawrence Berkeley National Laboratory and STFC.
      
    </div>

    

    

  </body>
</html>