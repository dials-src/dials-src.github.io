
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dials.integrate &mdash; DIALS  documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/dials-styles.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/dials_icon.png"/>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="DIALS  documentation" href="../../index.html" />
    <link rel="up" title="Program documentation" href="index.html" />
    <link rel="next" title="dials.export_mtz" href="dials_export_mtz.html" />
    <link rel="prev" title="dials.refine" href="dials_refine.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body>
  <div class="logoheader container">
  <a href="../../index.html">
  <img class="logoheader" alt="DIALS" src="../../_static/dials_header.png" />
  </a>
  </div>
  


  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="dials-integrate">
<h1>dials.integrate<a class="headerlink" href="#dials-integrate" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This program is used to integrate the reflections on the diffraction images. It
is called with an experiment list outputted from dials.index or dials.refine.
The extend of the shoeboxes is specified through the profile parameters
shoebox.sigma_b and shoebox.sigma_m (use the &#8211;show-config option for more
details). These parameters can be specified directly, otherwise a set of strong
indexed reflections are needed to form the profile model; these are specified
using the -r (for reference) option. The program can also be called with a
specific set of predictions using the -p option.</p>
<p>Once a profile model is given and the size of the measurement boxes have been
calculated, the program will extract the reflections to file. The reflections
will then be integrated. The reflections can be integrated with different
options using the same measurement boxes by giving the measurement box file
using the -s option. This will skip reading the measurement boxes and go
directly to integrating the reflections.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre>dials.integrate experiments.json input.reflections=indexed.pickle

dials.integrate experiments.json input.reflections=indexed.pickle output.reflections=integrated.pickle

dials.integrate experiments.json profile.phil

dials.integrate experiments.json predicted=predicted.pickle reference=indexed.pickle
</pre></div>
</div>
</div>
<div class="section" id="basic-parameters">
<h2>Basic parameters<a class="headerlink" href="#basic-parameters" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">
output {
  experiments = 'integrated_experiments.json'
  reflections = 'integrated.pickle'
  phil = 'dials.integrate.phil'
  log = 'dials.integrate.log'
  debug_log = 'dials.integrate.debug.log'
  report = None
}
scan_range = None
verbosity = 1
integration {
  mp {
    method = *multiprocessing sge lsf pbs
    nproc = 1
    nthreads = 1
  }
  lookup {
    mask = None
  }
  block {
    size = auto
    units = *degrees radians frames
    threshold = 0.99
    force = False
    max_memory_usage = 0.75
  }
  debug {
    during = modelling *integration
    output = False
    select = None
    split_experiments = True
  }
  profile {
    fitting = True
    validation {
      number_of_partitions = 1
      min_partition_size = 100
    }
  }
  background {
    algorithm = *simple null glm
    simple {
      outlier {
        algorithm = null *nsigma truncated normal mosflm tukey
      }
      model {
        algorithm = constant2d *constant3d linear2d linear3d
      }
    }
    glm {
      robust {
        tuning_constant = 1.345
      }
      model {
        algorithm = constant2d *constant3d loglinear2d loglinear3d
      }
    }
  }
  centroid {
    algorithm = *simple
  }
}
profile {
  algorithm = gaussian_rs *gaussian_rs
  gaussian_rs {
    scan_varying = False
    min_spots = 100
    filter {
      min_zeta = 0.05
    }
    fitting {
      scan_step = 5
      grid_size = 5
      threshold = 0.02
      grid_method = single *regular_grid circular_grid
      fit_method = *reciprocal_space detector_space
    }
  }
  gaussian_rs {
    scan_varying = False
    min_spots = 100
    filter {
      min_zeta = 0.05
    }
    fitting {
      scan_step = 5
      grid_size = 5
      threshold = 0.02
      grid_method = single *regular_grid circular_grid
      fit_method = *reciprocal_space detector_space
    }
  }
}
prediction {
  d_min = None
  d_max = None
  margin = 1
  force_static = False
}

</pre>
</div>
<div class="section" id="full-parameter-definitions">
<h2>Full parameter definitions<a class="headerlink" href="#full-parameter-definitions" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">
output {
  experiments = 'integrated_experiments.json'
    .help = &quot;The experiments output filename&quot;
    .type = str
  reflections = 'integrated.pickle'
    .help = &quot;The integrated output filename&quot;
    .type = str
  phil = 'dials.integrate.phil'
    .help = &quot;The output phil file&quot;
    .type = str
  log = 'dials.integrate.log'
    .help = &quot;The log filename&quot;
    .type = str
  debug_log = 'dials.integrate.debug.log'
    .help = &quot;The debug log filename&quot;
    .type = str
  report = None
    .help = &quot;The integration report filename (*.xml or *.json)&quot;
    .type = str
}
scan_range = None
  .help = &quot;Explicitly specify the images to be processed. Only applicable when&quot;
          &quot;experiment list contains a single imageset.&quot;
  .type = ints(size=2)
  .multiple = True
sampling
  .expert_level = 1
{
  reflections_per_degree = 50
    .help = &quot;The number of predicted reflections per degree of the sweep  to&quot;
            &quot;integrate.&quot;
    .type = float(value_min=0)
  minimum_sample_size = 1000
    .help = &quot;cutoff that determines whether subsetting of the input &quot;
            &quot;prediction list is done&quot;
    .type = int
  maximum_sample_size = None
    .help = &quot;The maximum number of predictions to integrate. Overrides&quot;
            &quot;reflections_per_degree if that produces a larger sample size.&quot;
    .type = int(value_min=1)
  integrate_all_reflections = True
    .help = &quot;Override reflections_per_degree and integrate all predicted&quot;
            &quot;reflections.&quot;
    .type = bool
}
verbosity = 1
  .help = &quot;The verbosity level&quot;
  .type = int(value_min=0)
integration {
  mp {
    method = *multiprocessing sge lsf pbs
      .help = &quot;The multiprocessing method to use&quot;
      .type = choice
    nproc = 1
      .help = &quot;The number of processes to use.&quot;
      .type = int(value_min=1)
    nthreads = 1
      .help = &quot;The number of local threads to use for openmp.&quot;
      .type = int(value_min=1)
  }
  lookup
    .help = &quot;Parameters specifying lookup file path&quot;
  {
    mask = None
      .help = &quot;The path to the mask file.&quot;
      .type = str
  }
  block {
    size = auto
      .help = &quot;The block size in rotation angle (degrees).&quot;
      .type = float
    units = *degrees radians frames
      .help = &quot;The units of the block size&quot;
      .type = choice
    threshold = 0.99
      .help = &quot;For block size auto the block size is calculated by sorting&quot;
              &quot;reflections by the number of frames they cover and then&quot;
              &quot;selecting the block size to be 2*nframes[threshold] such that&quot;
              &quot;100*threshold % of reflections are guarenteed to be fully&quot;
              &quot;contained in 1 block&quot;
      .type = float(value_min=0, value_max=1)
    force = False
      .help = &quot;If the number of processors is 1 and force is False, then the&quot;
              &quot;number of blocks may be set to 1. If force is True then the&quot;
              &quot;block size is always calculated.&quot;
      .type = bool
    max_memory_usage = 0.75
      .help = &quot;The maximum percentage of total physical memory to use for&quot;
              &quot;allocating shoebox arrays.&quot;
      .type = float(value_min=0, value_max=1)
  }
  debug {
    during = modelling *integration
      .help = &quot;Do debugging during modelling or integration&quot;
      .type = choice
    output = False
      .help = &quot;Save shoeboxes after each processing task.&quot;
      .type = bool
    select = None
      .help = &quot;A string specifying the selection. The string should be of the&quot;
              &quot;form: select=${COLUMN}[&lt;<a href="#id1"><span class="problematic" id="id2">|&lt;=|==|</span></a>!=|&gt;=|&gt;]${VALUE}. In addition to&quot;
              &quot;the items in the reflection table, the following implicit&quot;
              &quot;columns are defined if the necessary data is there: &quot;
              &quot;intensity.sum.i_over_sigma  intensity.prf.i_over_sigma&quot;
      .type = reflection_table_selector
    split_experiments = True
      .help = &quot;Split shoeboxes into different files&quot;
      .type = bool
  }
  profile {
    fitting = True
      .help = &quot;Use profile fitting if available&quot;
      .type = bool
    validation {
      number_of_partitions = 1
        .help = &quot;The number of subsamples to take from the reference spots. If&quot;
                &quot;the value is 1, then no validation is performed.&quot;
        .type = int(value_min=1)
      min_partition_size = 100
        .help = &quot;The minimum number of spots to use in each subsample.&quot;
        .type = int(value_min=1)
    }
  }
  filter
    .expert_level = 1
  {
    min_zeta = 0.05
      .help = &quot;Filter the reflections by the value of zeta. A value of less&quot;
              &quot;than or equal to zero indicates that this will not be used. A&quot;
              &quot;positive value is used as the minimum permissable value.&quot;
      .type = float(value_min=0, value_max=1)
    max_shoebox_overlap = 1.0
      .help = &quot;Filter reflections whose shoeboxes are overlapped by greater&quot;
              &quot;than the requested amount. Note that this is not the percentage&quot;
              &quot;of the peak that is overlapped but rather the percentage of the&quot;
              &quot;shoebox (background and foreground). This can be useful when&quot;
              &quot;the detector is too close and many overlapping reflections are&quot;
              &quot;predicted at high resolution causing memory issues.&quot;
      .type = float(value_min=0, value_max=1)
    powder {
      water_ice {
        unit_cell = 4.498,4.498,7.338,90,90,120
          .help = &quot;The unit cell to generate d_spacings for ice rings.&quot;
          .type = unit_cell
        space_group = 194
          .help = &quot;The space group used to generate d_spacings for ice rings.&quot;
          .type = space_group
        d_min = 1
          .help = &quot;The minimum resolution to filter ice rings&quot;
          .type = float(value_min=0)
        width = 0.06
          .help = &quot;The width of an ice ring (in d-spacing).&quot;
          .type = float(value_min=0)
      }
      apply = *none water_ice
        .help = &quot;The power ring filters to apply&quot;
        .type = choice(multi=True)
    }
  }
  background
    .help = &quot;  I n t e r f a c e   f o r   b a c k g r o u n d   a l g o r i t&quot;
            &quot;h m s .  &quot;
  {
    algorithm = *simple null glm
      .help = &quot;The choice of algorithm&quot;
      .type = choice
    simple
      .help = &quot;An extension class implementing XDS background subtraction.&quot;
    {
      outlier
        .help = &quot;Outlier rejection prior to background fit&quot;
      {
        algorithm = null *nsigma truncated normal mosflm tukey
          .help = &quot;The outlier rejection algorithm.&quot;
          .type = choice
        nsigma
          .help = &quot;Parameters for nsigma outlier rejector&quot;
          .expert_level = 1
        {
          lower = 3
            .help = &quot;Lower n sigma&quot;
            .type = float
          upper = 3
            .help = &quot;Upper n sigma&quot;
            .type = float
        }
        truncated
          .help = &quot;Parameters for truncated outlier rejector&quot;
          .expert_level = 1
        {
          lower = 0.01
            .help = &quot;Lower bound&quot;
            .type = float
          upper = 0.01
            .help = &quot;Upper bound&quot;
            .type = float
        }
        normal
          .help = &quot;Parameters for normal outlier rejector&quot;
          .expert_level = 1
        {
          min_pixels = 10
            .help = &quot;The minimum number of pixels to use in calculating the&quot;
                    &quot;background intensity.&quot;
            .type = int
        }
        mosflm
          .help = &quot;Parameters for mosflm-like outlier rejector. This algorithm&quot;
                  &quot;is mainly used in conjunction with a linear 2d background.&quot;
          .expert_level = 1
        {
          fraction = 1.0
            .help = &quot;The fraction of pixels to use in determining the initial&quot;
                    &quot;plane used for outlier rejection.&quot;
            .type = float
          n_sigma = 4.0
            .help = &quot;The number of standard deviations above the threshold&quot;
                    &quot;plane to use in rejecting outliers from background&quot;
                    &quot;calculation.&quot;
            .type = float
        }
        tukey
          .help = &quot;Parameters for tukey outlier rejector&quot;
          .expert_level = 1
        {
          lower = 1.5
            .help = &quot;Lower IQR multiplier&quot;
            .type = float
          upper = 1.5
            .help = &quot;Upper IQR multiplier&quot;
            .type = float
        }
      }
      model
        .help = &quot;Background model&quot;
      {
        algorithm = constant2d *constant3d linear2d linear3d
          .help = &quot;The choice of background model&quot;
          .type = choice
      }
    }
    glm
      .help = &quot;An extension class implementing XDS background subtraction.&quot;
    {
      robust {
        tuning_constant = 1.345
          .help = &quot;The tuning constant for robust estimation&quot;
          .type = float
      }
      model {
        algorithm = constant2d *constant3d loglinear2d loglinear3d
          .help = &quot;The background model to fit&quot;
          .type = choice
      }
    }
  }
  centroid
    .help = &quot;  I n t e r f a c e   f o r   c e n t r o i d   a l g o r i t h m&quot;
            &quot;s .  &quot;
  {
    algorithm = *simple
      .help = &quot;The choice of algorithm&quot;
      .type = choice
  }
}
profile
  .help = &quot;
     T h e   i n t e r f a c e   d e f i n i t i o n   f o r   a  &quot;
          &quot;p r o f i l e   m o d e l . 
 
    &quot;
{
  algorithm = gaussian_rs *gaussian_rs
    .help = &quot;The choice of algorithm&quot;
    .type = choice
  gaussian_rs
    .help = &quot;An extension class implementing a reciprocal space gaussian&quot;
            &quot;profile model.&quot;
  {
    scan_varying = False
      .help = &quot;Calculate a scan varying model&quot;
      .type = bool
    min_spots = 100
      .help = &quot;The minimum number of spots needed to do the profile modelling&quot;
      .type = int(value_min=0)
    filter {
      min_zeta = 0.05
        .help = &quot;Filter reflections by min zeta&quot;
        .type = float
    }
    fitting {
      scan_step = 5
        .help = &quot;Space between profiles in degrees&quot;
        .type = float
      grid_size = 5
        .help = &quot;The size of the profile grid.&quot;
        .type = int
      threshold = 0.02
        .help = &quot;The threshold to use in reference profile&quot;
        .type = float
      grid_method = single *regular_grid circular_grid
        .help = &quot;Select the profile grid method&quot;
        .type = choice
      fit_method = *reciprocal_space detector_space
        .help = &quot;The fitting method&quot;
        .type = choice
    }
  }
  gaussian_rs
    .help = &quot;An extension class implementing a reciprocal space gaussian&quot;
            &quot;profile model.&quot;
  {
    scan_varying = False
      .help = &quot;Calculate a scan varying model&quot;
      .type = bool
    min_spots = 100
      .help = &quot;The minimum number of spots needed to do the profile modelling&quot;
      .type = int(value_min=0)
    filter {
      min_zeta = 0.05
        .help = &quot;Filter reflections by min zeta&quot;
        .type = float
    }
    fitting {
      scan_step = 5
        .help = &quot;Space between profiles in degrees&quot;
        .type = float
      grid_size = 5
        .help = &quot;The size of the profile grid.&quot;
        .type = int
      threshold = 0.02
        .help = &quot;The threshold to use in reference profile&quot;
        .type = float
      grid_method = single *regular_grid circular_grid
        .help = &quot;Select the profile grid method&quot;
        .type = choice
      fit_method = *reciprocal_space detector_space
        .help = &quot;The fitting method&quot;
        .type = choice
    }
  }
}
prediction {
  d_min = None
    .help = &quot;The maximum resolution limit&quot;
    .type = float
  d_max = None
    .help = &quot;The minimum resolution limit&quot;
    .type = float
  margin = 1
    .help = &quot;The margin to use to scan varying prediction&quot;
    .type = int
  force_static = False
    .help = &quot;For scan-varying prediction for scan-static&quot;
    .type = bool
}

</pre>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">DIALS</a></h1>



<p class="blurb">Data Integration for Advanced Light Sources</p>




<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../links.html">Links</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer container">
  <a href="http://www.diamond.ac.uk/"><img class="logofooter" alt="Diamond" src="../../_static/diamond_logo.png" /></a>
  <a href="http://www.ccp4.ac.uk/"><img class="logofooter" alt="CCP4" src="../../_static/CCP4-logo-plain.png" /></a>
  <a href="http://www.lbl.gov/"><img class="logofooter" alt="LBL" src="../../_static/LBL-logo-wide.jpeg" /></a>
  <a href="https://www.stfc.ac.uk/"><img class="logofooter" alt="STFC" src="../../_static/STFC_logo.png" /></a>
  </div>
  
    <div class="footer">
      &copy;2015, Diamond Light Source, Lawrence Berkeley National Laboratory and STFC.
      
    </div>

    

    

  </body>
</html>