
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dials.process &mdash; DIALS  documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/dials-styles.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/dials-styles.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/dials_icon.png"/>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="DIALS  documentation" href="../../index.html" />
    <link rel="up" title="Program documentation" href="index.html" />
    <link rel="next" title="dials.import" href="dials_import.html" />
    <link rel="prev" title="Program documentation" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body>
  <div class="logoheader container">
  <a href="../../index.html">
  <img class="logoheader" alt="DIALS" src="../../_static/dials_header.png" />
  </a>
  </div>
  


  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="dials-process">
<h1>dials.process<a class="headerlink" href="#dials-process" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This is the main dials program. Given a set of images, the data will be
processed and a list of integrated reflections will be given as output. More
specialised help can be seen by looking at the command line programs that
perform the individual processing steps. See at the following for more
details:</p>
<div class="highlight-python"><div class="highlight"><pre>dials.import
dials.find_spots
dials.index
dials.refine
dials.integrate
dials.export_mtz
</pre></div>
</div>
<p>This program will do the following:</p>
<blockquote>
<div>First the image data will be imported into a datablock. Strong spots will then
be found on all the images of the datablock. These strong spots will then be
indexed (the indexing step also includes some static centroid refinement). The
experimental geometry will then be refined and the reflections integrated.
Finally, the integrated reflections will be exported to an MTZ file which can
be input into Aimless to be scaled.</div></blockquote>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre>dials.process images*.cbf

dials.process datablock.json

find . -name &quot;images*.cbf&quot; | dials.process
</pre></div>
</div>
</div>
<div class="section" id="basic-parameters">
<h2>Basic parameters<a class="headerlink" href="#basic-parameters" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">
verbosity = 1
input {
  template = None
}
output {
  datablock_filename = datablock.json
  strong_filename = strong.pickle
  indexed_filename = indexed.pickle
  refined_experiments_filename = refined_experiments.json
  integrated_filename = integrated.pickle
  profile_filename = profile.phil
  mtz_filename = integrated.mtz
}
spotfinder {
  lookup {
    mask = None
  }
  mp {
    method = *multiprocessing sge lsf pbs
    nproc = 1
    nthreads = 1
  }
  write_hot_mask = True
  scan_range = None
  filter {
    min_spot_size = Auto
    d_min = None
    d_max = None
    max_strong_pixel_fraction = 0.25
    ice_rings {
      filter = False
    }
    untrusted_polygon = None
  }
  threshold {
    algorithm = *xds
    xds {
      gain = None
      global_threshold = 0
    }
  }
}
indexing {
  nproc = 1
  max_cell = Auto
  max_cell_multiplier = 1.3
  fft3d {
    reciprocal_space_grid {
      d_min = Auto
    }
  }
  scan_range = None
  known_symmetry {
    space_group = None
    unit_cell = None
  }
  index_assignment {
    simple {
      hkl_tolerance = 0.3
    }
  }
  refinement_protocol {
    n_macro_cycles = 5
    d_min_step = Auto
    d_min_start = 4.0
    d_min_final = None
    verbosity = 1
    outlier_rejection {
      maximum_spot_error = None
      maximum_phi_error = None
    }
  }
  method = *fft3d fft1d real_space_grid_search
}
refinement {
  verbosity = 1
  parameterisation {
    auto_reduction {
      min_nref_per_parameter = 5
      action = *fail fix remove
    }
    beam {
      fix = all *in_spindle_plane out_spindle_plane *wavelength
    }
    crystal {
      fix = all cell orientation
      scan_varying = False
    }
    detector {
      fix = all position orientation
    }
  }
  reflections {
    reflections_per_degree = 100
    minimum_sample_size = 1000
    maximum_sample_size = None
    use_all_reflections = False
    outlier {
      algorithm = null *auto mcd tukey sauter_poon
      minimum_number_of_reflections = 20
      separate_experiments = True
      separate_panels = True
    }
  }
}
integration {
  mp {
    method = *multiprocessing sge lsf pbs
    nproc = 1
    nthreads = 1
  }
  lookup {
    mask = None
  }
  block {
    size = auto
    units = *degrees radians frames
    threshold = 0.99
    force = False
    max_memory_usage = 0.75
  }
  debug {
    reference {
      output = False
    }
    during = modelling *integration
    output = False
    select = None
    split_experiments = True
  }
  profile {
    fitting = True
    validation {
      number_of_partitions = 1
      min_partition_size = 100
    }
  }
  background {
    algorithm = *simple null glm
    simple {
      outlier {
        algorithm = null *nsigma truncated normal mosflm tukey
      }
      model {
        algorithm = constant2d *constant3d linear2d linear3d
      }
    }
    glm {
      robust {
        tuning_constant = 1.345
      }
      model {
        algorithm = constant2d *constant3d loglinear2d loglinear3d
      }
    }
  }
  centroid {
    algorithm = *simple
  }
}
profile {
  algorithm = gaussian_rs *gaussian_rs
  gaussian_rs {
    scan_varying = False
    min_spots = 100
    filter {
      min_zeta = 0.05
    }
    fitting {
      scan_step = 5
      grid_size = 5
      threshold = 0.02
      grid_method = single *regular_grid circular_grid
      fit_method = *reciprocal_space detector_space
    }
  }
  gaussian_rs {
    scan_varying = False
    min_spots = 100
    filter {
      min_zeta = 0.05
    }
    fitting {
      scan_step = 5
      grid_size = 5
      threshold = 0.02
      grid_method = single *regular_grid circular_grid
      fit_method = *reciprocal_space detector_space
    }
  }
}
prediction {
  d_min = None
  d_max = None
  margin = 1
  force_static = False
}

</pre>
</div>
<div class="section" id="full-parameter-definitions">
<h2>Full parameter definitions<a class="headerlink" href="#full-parameter-definitions" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">
verbosity = 1
  .help = &quot;The verbosity level&quot;
  .type = int(value_min=0)
input {
  template = None
    .help = &quot;The image sweep template&quot;
    .type = str
    .multiple = True
}
output {
  datablock_filename = datablock.json
    .help = &quot;The filename for output datablock&quot;
    .type = str
  strong_filename = strong.pickle
    .help = &quot;The filename for strong reflections from spot finder output.&quot;
    .type = str
  indexed_filename = indexed.pickle
    .help = &quot;The filename for indexed reflections.&quot;
    .type = str
  refined_experiments_filename = refined_experiments.json
    .help = &quot;The filename for saving refined experimental models&quot;
    .type = str
  integrated_filename = integrated.pickle
    .help = &quot;The filename for final integrated reflections.&quot;
    .type = str
  profile_filename = profile.phil
    .help = &quot;The filename for output reflection profile parameters&quot;
    .type = str
  mtz_filename = integrated.mtz
    .help = &quot;The filename for output mtz&quot;
    .type = str
}
spotfinder
  .help = &quot;Parameters used in the spot finding algorithm.&quot;
{
  lookup
    .help = &quot;Parameters specifying lookup file path&quot;
  {
    mask = None
      .help = &quot;The path to the mask file.&quot;
      .type = str
  }
  mp {
    method = *multiprocessing sge lsf pbs
      .help = &quot;The multiprocessing method to use&quot;
      .type = choice
    nproc = 1
      .help = &quot;The number of processes to use.&quot;
      .type = int(value_min=1)
    nthreads = 1
      .help = &quot;The number of local threads to use for openmp.&quot;
      .type = int(value_min=1)
  }
  write_hot_mask = True
    .help = &quot;Write the hot mask&quot;
    .type = bool
  scan_range = None
    .help = &quot;The range of images to use in finding spots. Number of arguments&quot;
            &quot;must be a factor of two. Specifying  0 0&quot; will use all images&quot;&quot;
            &quot;by default. The given range follows C conventions (e.g. j0 &lt;= j &lt;&quot;
            &quot;j1). For sweeps the scan range is interpreted as the literal scan&quot;
            &quot;range. Whereas for imagesets the scan range is interpreted as the&quot;
            &quot;image number in the imageset&quot;
    .type = ints(size=2)
    .multiple = True
  filter
    .help = &quot;Parameters used in the spot finding filter strategy.&quot;
  {
    min_spot_size = Auto
      .help = &quot;The minimum number of contiguous pixels for a spot to be&quot;
              &quot;accepted by the filtering algorithm.&quot;
      .type = int(value_min=0)
    max_separation = 2
      .help = &quot;The maximum peak-to-centroid separation (in pixels) for a spot&quot;
              &quot;to be accepted by the filtering algorithm.&quot;
      .type = float(value_min=0)
      .expert_level = 1
    d_min = None
      .help = &quot;The high resolution limit in Angstrom for a spot to be accepted&quot;
              &quot;by the filtering algorithm.&quot;
      .type = float(value_min=0)
    d_max = None
      .help = &quot;The low resolution limit in Angstrom for a spot to be accepted&quot;
              &quot;by the filtering algorithm.&quot;
      .type = float(value_min=0)
    max_strong_pixel_fraction = 0.25
      .help = &quot;If the fraction of pixels in an image marked as strong is&quot;
              &quot;greater than this value, throw an exception&quot;
      .type = float(value_min=0, value_max=1)
    background_gradient
      .expert_level = 2
    {
      filter = False
        .type = bool
      background_size = 2
        .type = int(value_min=1)
      gradient_cutoff = 4
        .type = float(value_min=0)
    }
    spot_density
      .expert_level = 2
    {
      filter = False
        .type = bool
    }
    ice_rings {
      filter = False
        .type = bool
      unit_cell = 4.498,4.498,7.338,90,90,120
        .help = &quot;The unit cell to generate d_spacings for powder rings.&quot;
        .type = unit_cell
        .expert_level = 1
      space_group = 194
        .help = &quot;The space group used to generate d_spacings for powder rings.&quot;
        .type = space_group
        .expert_level = 1
      width = 0.06
        .help = &quot;The width of an ice ring (in d-spacing).&quot;
        .type = float(value_min=0)
        .expert_level = 1
    }
    untrusted_polygon = None
      .help = &quot;The pixel coordinates (fast, slow) that define the corners  of&quot;
              &quot;the untrusted polygon. Spots whose centroids fall within  the&quot;
              &quot;bounds of the untrusted polygon will be rejected.&quot;
      .type = ints(value_min=0)
      .multiple = True
  }
  threshold
    .help = &quot;  I n t e r f a c e   f o r   t h r e s h o l d   a l g o r i t h&quot;
            &quot;m s   t o   b e   u s e d   i n   s p o t   f i n d i n g .  &quot;
  {
    algorithm = *xds
      .help = &quot;The choice of algorithm&quot;
      .type = choice
    xds
      .help = &quot;Extensions to do xds-like threshold.&quot;
    {
      gain = None
        .help = &quot;Use a flat gain map for the entire detector. Cannot be used&quot;
                &quot;in conjunction with lookup.gain_map parameter.&quot;
        .type = float(value_min=0)
      kernel_size = 3 3
        .help = &quot;The size of the local area around the spot in which to&quot;
                &quot;calculate the mean and variance. The kernel is given as a box&quot;
                &quot;of size (2 * nx + 1, 2 * ny + 1) centred at the pixel.&quot;
        .type = ints(size=2)
        .expert_level = 1
      sigma_background = 6
        .help = &quot;The number of standard deviations of the coefficient of&quot;
                &quot;variation (variance / mean) in the local area below which the&quot;
                &quot;pixel will be classified as background.&quot;
        .type = float
        .expert_level = 1
      sigma_strong = 3
        .help = &quot;The number of standard deviations above the mean in the local&quot;
                &quot;area above which the pixel will be classified as strong.&quot;
        .type = float
        .expert_level = 1
      min_local = 2
        .help = &quot;The minimum number of pixels under the image processing&quot;
                &quot;kernel that are need to do the thresholding operation.&quot;
                &quot;Setting the value between 2 and the total number of pixels&quot;
                &quot;under the kernel will force the algorithm to use that number&quot;
                &quot;as the minimum. If the value is less than or equal to zero,&quot;
                &quot;then the algorithm will use all pixels under the kernel. In&quot;
                &quot;effect this will add a border of pixels which are always&quot;
                &quot;classed as background around the edge of the image and around&quot;
                &quot;any masked out pixels.&quot;
        .type = int
        .expert_level = 1
      global_threshold = 0
        .help = &quot;The global threshold value. Consider all pixels less than&quot;
                &quot;this value to be part of the background.&quot;
        .type = float
    }
  }
}
indexing {
  nproc = 1
    .help = &quot;The number of processes to use.&quot;
    .type = int(value_min=1)
  discover_better_experimental_model = False
    .type = bool
    .expert_level = 1
  mm_search_scope = 4.0
    .help = &quot;Global radius of origin offset search.&quot;
    .type = float(value_min=0)
    .expert_level = 1
  wide_search_binning = 2
    .help = &quot;Modify the coarseness of the wide grid search for the beam&quot;
            &quot;centre.&quot;
    .type = float(value_min=0)
    .expert_level = 1
  min_cell = 3
    .help = &quot;Minimum length of candidate unit cell basis vectors (in&quot;
            &quot;Angstrom).&quot;
    .type = float(value_min=0)
    .expert_level = 1
  max_cell = Auto
    .help = &quot;Maximum length of candidate unit cell basis vectors (in&quot;
            &quot;Angstrom).&quot;
    .type = float(value_min=0)
  max_cell_multiplier = 1.3
    .help = &quot;Multiply the estimated maximum basis vector length by this value.&quot;
    .type = float(value_min=0)
  nearest_neighbor_percentile = 0.05
    .help = &quot;Percentile of NN histogram to use for max cell determination.&quot;
    .type = float(value_min=0)
    .expert_level = 1
  fft3d {
    peak_search = *flood_fill clean
      .type = choice
      .expert_level = 2
    peak_volume_cutoff = 0.15
      .type = float
      .expert_level = 2
    reciprocal_space_grid {
      n_points = 256
        .type = int(value_min=0)
        .expert_level = 1
      d_min = Auto
        .help = &quot;The high resolution limit in Angstrom for spots to include in&quot;
                &quot; the initial indexing.&quot;
        .type = float(value_min=0)
    }
  }
  sigma_phi_deg = None
    .help = &quot;Override the phi sigmas for refinement. Mainly intended for&quot;
            &quot;single-shot rotation images where the phi sigma is almost&quot;
            &quot;certainly incorrect.&quot;
    .type = float(value_min=0)
    .expert_level = 2
  b_iso = Auto
    .type = float(value_min=0)
    .expert_level = 2
  rmsd_cutoff = 15
    .type = float(value_min=0)
    .expert_level = 1
  scan_range = None
    .help = &quot;The range of images to use in indexing. Number of arguments must&quot;
            &quot;be a factor of two. Specifying  0 0&quot; will use all images&quot; by&quot;
            &quot;default. The given range follows C conventions (e.g. j0 &lt;= j &lt;&quot;
            &quot;j1).&quot;
    .type = ints(size=2)
    .multiple = True
  known_symmetry {
    space_group = None
      .help = &quot;Target space group for indexing.&quot;
      .type = space_group
    unit_cell = None
      .help = &quot;Target unit cell for indexing.&quot;
      .type = unit_cell
    relative_length_tolerance = 0.1
      .help = &quot;Relative tolerance for unit cell lengths in unit cell&quot;
              &quot;comparision.&quot;
      .type = float
      .expert_level = 1
    absolute_angle_tolerance = 5
      .help = &quot;Angular tolerance (in degrees) in unit cell comparison.&quot;
      .type = float
      .expert_level = 1
    max_delta = 5
      .help = &quot;Maximum allowed Le Page delta used in searching for basis&quot;
              &quot;vector combinations that are consistent with the given&quot;
              &quot;symmetry.&quot;
      .type = float(value_min=0)
      .expert_level = 1
  }
  basis_vector_combinations
    .expert_level = 1
  {
    max_try = 50
      .help = &quot;Number of putative basis vector combinations to try.&quot;
      .type = int(value_min=1)
      .expert_level = 1
    solution_scorer = filter *weighted
      .type = choice
      .expert_level = 1
    filter
      .expert_level = 1
    {
      check_doubled_cell = True
        .type = bool
      likelihood_cutoff = 0.8
        .type = float(value_min=0, value_max=1)
      volume_cutoff = 1.25
        .type = float(value_min=1)
      n_indexed_cutoff = 0.9
        .type = float(value_min=0, value_max=1)
    }
    weighted
      .expert_level = 1
    {
      power = 1
        .type = int(value_min=1)
    }
  }
  index_assignment {
    method = *simple local
      .help = &quot;Choose between simple 'global' index assignment and xds-style &quot;
              &quot;'local' index assignment.&quot;
      .type = choice
      .expert_level = 1
    simple {
      hkl_tolerance = 0.3
        .help = &quot;Maximum allowable deviation from integer-ness for assigning &quot;
                &quot;a miller index to a reciprocal lattice vector.&quot;
        .type = float(value_min=0, value_max=0.5)
    }
    local
      .expert_level = 1
    {
      epsilon = 0.05
        .help = &quot;This corresponds to the xds parameter INDEX_ERROR=&quot;
        .type = float
      delta = 8
        .help = &quot;This corresponds to the xds parameter INDEX_MAGNITUDE=&quot;
        .type = int
      l_min = 0.8
        .help = &quot;This corresponds to the xds parameter INDEX_QUALITY=&quot;
        .type = float
      nearest_neighbours = 20
        .type = int(value_min=1)
    }
  }
  optimise_initial_basis_vectors = False
    .type = bool
    .expert_level = 2
  debug = False
    .type = bool
    .expert_level = 1
  debug_plots = False
    .help = &quot;Requires matplotlib&quot;
    .type = bool
    .expert_level = 1
  refinement_protocol {
    n_macro_cycles = 5
      .type = int(value_min=1)
    d_min_step = Auto
      .help = &quot;Reduction per step in d_min for reflections to include in&quot;
              &quot;refinement.&quot;
      .type = float(value_min=0)
    d_min_start = 4.0
      .type = float(value_min=0)
    d_min_final = None
      .help = &quot;Do not ever include reflections below this value in refinement.&quot;
      .type = float(value_min=0)
    verbosity = 1
      .type = int(value_min=0)
    disable_unit_cell_volume_sanity_check = False
      .help = &quot;Disable sanity check on unrealistic increases in unit cell&quot;
              &quot;volume during refinement.&quot;
      .type = bool
      .expert_level = 1
    outlier_rejection {
      maximum_spot_error = None
        .help = &quot;Reject reflections whose predicted and observed centroids&quot;
                &quot;differ  by more than the given multiple of the pixel size. No&quot;
                &quot;outlier rejection is performed in the first macro cycle, and &quot;
                &quot;in the second macro cycle twice the given multiple is used.&quot;
        .type = float(value_min=0)
      maximum_phi_error = None
        .help = &quot;Reject reflections whose predicted and observed phi centroids&quot;
                &quot; differ by more than the given value (degrees). No outlier&quot;
                &quot;rejection is performed in the first macro cycle, and  in the&quot;
                &quot;second macro cycle twice the given multiple is used.&quot;
        .type = float(value_min=0)
    }
  }
  method = *fft3d fft1d real_space_grid_search
    .type = choice
  multiple_lattice_search
    .expert_level = 1
  {
    cluster_analysis_search = False
      .help = &quot;Perform cluster analysis search for multiple lattices.&quot;
      .type = bool
    recycle_unindexed_reflections = False
      .help = &quot;Attempt another cycle of indexing on the unindexed reflections &quot;
              &quot;if enough reflections are unindexed.&quot;
      .type = bool
    recycle_unindexed_reflections_cutoff = 0.1
      .help = &quot;Attempt another cycle of indexing on the unindexed reflections &quot;
              &quot;if more than the fraction of input reflections are unindexed.&quot;
      .type = float(value_min=0, value_max=1)
    minimum_angular_separation = 5
      .help = &quot;The minimum angular separation (in degrees) between two&quot;
              &quot;lattices.&quot;
      .type = float(value_min=0)
    max_lattices = None
      .type = int
    cluster_analysis {
      method = *dbscan hcluster
        .type = choice
      hcluster {
        linkage {
          method = *ward
            .type = choice
          metric = *euclidean
            .type = choice
        }
        cutoff = 15
          .type = float(value_min=0)
        cutoff_criterion = *distance inconsistent
          .type = choice
      }
      dbscan {
        eps = 0.05
          .type = float(value_min=0)
        min_samples = 30
          .type = int(value_min=1)
      }
      min_cluster_size = 20
        .type = int(value_min=0)
      intersection_union_ratio_cutoff = 0.4
        .type = float(value_min=0, value_max=1)
    }
  }
  real_space_grid_search
    .expert_level = 1
  {
    characteristic_grid = 0.02
      .type = float(value_min=0)
  }
}
refinement
  .help = &quot;Parameters to configure the refinement&quot;
{
  mp
    .expert_level = 1
  {
    nproc = 1
      .help = &quot;The number of processes to use. Only applicable to certain&quot;
              &quot;choices of refinement engine!&quot;
      .type = int(value_min=1)
  }
  verbosity = 1
    .help = &quot;verbosity level&quot;
    .type = int(value_min=0)
  parameterisation
    .help = &quot;Parameters to control the parameterisation of experimental models&quot;
  {
    auto_reduction
      .help = &quot;determine behaviour when there are too few reflections to&quot;
              &quot;reasonably produce a full parameterisation of the experiment&quot;
              &quot;list&quot;
    {
      min_nref_per_parameter = 5
        .help = &quot;the smallest number of reflections per parameter for a model&quot;
                &quot;parameterisation below which the parameterisation will not be&quot;
                &quot;made in full, but the action described below will be&quot;
                &quot;triggered.&quot;
        .type = int(value_min=1)
      action = *fail fix remove
        .help = &quot;action to take if there are too few reflections across the&quot;
                &quot;experiments related to a particular model parameterisation.&quot;
                &quot;If fail, an exception will be raised and refinement will not&quot;
                &quot;proceed. If fix, refinement will continue but with the&quot;
                &quot;parameters relating to that model remaining fixed at their&quot;
                &quot;initial values. If remove, parameters relating to that model&quot;
                &quot;will be fixed, and in addition all reflections related to&quot;
                &quot;that parameterisation will be removed. This will therefore&quot;
                &quot;remove this reflections from other parameterisations of the&quot;
                &quot;global model too. For example, if a crystal model could not&quot;
                &quot;be parameterised it will be excised completely and not&quot;
                &quot;contribute to the joint refinement of the detector and beam.&quot;
                &quot;In the fix mode, reflections emanating from that crystal will&quot;
                &quot;still form residuals and will contribute to detector and beam&quot;
                &quot;refinement.&quot;
        .type = choice
    }
    beam
      .help = &quot;beam parameters&quot;
    {
      fix = all *in_spindle_plane out_spindle_plane *wavelength
        .help = &quot;Whether to fix beam parameters. By default, in_spindle_plane&quot;
                &quot;is selected, and one of the two parameters is fixed. If a&quot;
                &quot;goniometer is present this leads to the beam orientation&quot;
                &quot;being restricted to a direction in the initial spindle-beam&quot;
                &quot;plane. Wavelength is also fixed by default, to allow&quot;
                &quot;refinement of the unit cell volume.&quot;
        .type = choice(multi=True)
      fix_list = None
        .help = &quot;Fix specified parameters by a list of indices&quot;
        .type = ints(value_min=0)
        .expert_level = 1
    }
    crystal
      .help = &quot;crystal parameters&quot;
    {
      fix = all cell orientation
        .help = &quot;Fix crystal parameters&quot;
        .type = choice
      cell_fix_list = None
        .help = &quot;Fix specified parameters by a list of indices&quot;
        .type = ints(value_min=0)
        .expert_level = 1
      orientation_fix_list = None
        .help = &quot;Fix specified parameters by a list of indices&quot;
        .type = ints(value_min=0)
        .expert_level = 1
      scan_varying = False
        .help = &quot;Parameterise the crystal to vary during the scan&quot;
        .type = bool
      num_intervals = *fixed_width absolute
        .help = &quot;Choose the way to determine the number of intervals for scan-&quot;
                &quot;varying refinement&quot;
        .type = choice
        .expert_level = 1
      interval_width_degrees = 36.0
        .help = &quot;Width of scan between checkpoints in degrees&quot;
        .type = float(value_min=0)
        .expert_level = 1
      absolute_num_intervals = 5
        .help = &quot;Number of intervals between checkpoints if scan_varying&quot;
                &quot;refinement is requested&quot;
        .type = int(value_min=1)
        .expert_level = 1
      UB_model_per = reflection image *block
        .help = &quot;Compose a new crystal model either every reflection (slow),&quot;
                &quot;every image (faster, less accurate) or within blocks of a&quot;
                &quot;width specified in the reflections parameters. When this&quot;
                &quot;block width is larger than the image width the result is&quot;
                &quot;faster again, with another trade-off in accuracy&quot;
        .type = choice
        .expert_level = 1
    }
    detector
      .help = &quot;detector parameters&quot;
    {
      panels = *automatic single multiple hierarchical
        .help = &quot;Select appropriate detector parameterisation. Both the single&quot;
                &quot;and multiple panel detector options treat the whole detector&quot;
                &quot;as a rigid body. The hierarchical parameterisation treats&quot;
                &quot;groups of panels as separate rigid bodies.&quot;
        .type = choice
        .expert_level = 1
      hierarchy_level = 0
        .help = &quot;Level of the detector hierarchy (starting from the root at 0)&quot;
                &quot;at which to determine panel groups to parameterise&quot;
                &quot;independently&quot;
        .type = int(value_min=0)
        .expert_level = 1
      fix = all position orientation
        .help = &quot;Fix detector parameters. The translational parameters&quot;
                &quot;(position) may be set separately to the orientation.&quot;
        .type = choice
      fix_list = None
        .help = &quot;Fix specified parameters by a list of indices&quot;
        .type = ints(value_min=0)
        .expert_level = 1
    }
    sparse = Auto
      .help = &quot;Calculate gradients using sparse data structures.&quot;
      .type = bool
      .expert_level = 1
    treat_single_image_as_still = False
      .help = &quot;Set this to True to treat a single image scan with a non zero&quot;
              &quot;oscillation width as a still&quot;
      .type = bool
      .expert_level = 1
  }
  refinery
    .help = &quot;Parameters to configure the refinery&quot;
    .expert_level = 1
  {
    engine = SimpleLBFGS LBFGScurvs GaussNewton *LevMar
      .help = &quot;The minimisation engine to use&quot;
      .type = choice
    track_step = False
      .help = &quot;Record parameter shifts history in the refinement journal, if&quot;
              &quot;the engine supports it.&quot;
      .type = bool
    track_gradient = False
      .help = &quot;Record parameter gradients history in the refinement journal,&quot;
              &quot;if the engine supports it.&quot;
      .type = bool
    track_parameter_correlation = False
      .help = &quot;Record correlation matrix between columns of the Jacobian for&quot;
              &quot;each step of refinement.&quot;
      .type = bool
    track_out_of_sample_rmsd = False
      .help = &quot;Record RMSDs calculated using the refined experiments with&quot;
              &quot;reflections not used in refinement at each step. Only valid if&quot;
              &quot;a subset of input reflections was taken for refinement&quot;
      .type = bool
    log = None
      .help = &quot;Filename for an optional log that a minimisation engine may use&quot;
              &quot;to write additional information&quot;
      .type = path
    max_iterations = None
      .help = &quot;Maximum number of iterations in refinement before termination.&quot;
              &quot;None implies the engine supplies its own default.&quot;
      .type = int(value_min=1)
  }
  target
    .help = &quot;Parameters to configure the target function&quot;
    .expert_level = 1
  {
    rmsd_cutoff = *fraction_of_bin_size absolute
      .help = &quot;Method to choose rmsd cutoffs. This is currently either as a&quot;
              &quot;fraction of the discrete units of the spot positional data,&quot;
              &quot;i.e. (pixel width, pixel height, image thickness in phi), or a&quot;
              &quot;tuple of absolute values to use as the cutoffs&quot;
      .type = choice
    bin_size_fraction = 0.2
      .help = &quot;Cut off in the natural discrete units of positional data, viz.,&quot;
              &quot;(pixel width, pixel height, image thickness in phi) to use to&quot;
              &quot;determine when the RMSD target is achieved. Only used if&quot;
              &quot;rmsd_cutoff = fraction_of_bin_size.&quot;
      .type = float(value_min=0)
    absolute_cutoffs = None
      .help = &quot;Absolute Values for the RMSD target achieved cutoffs in X, Y&quot;
              &quot;and Phi. The units are (mm, mm, rad).&quot;
      .type = floats(size=3, value_min=0)
    gradient_calculation_blocksize = None
      .help = &quot;Maximum number of reflections to use for gradient calculation.&quot;
              &quot;If there are more reflections than this in the manager then the&quot;
              &quot;minimiser must do the full calculation in blocks.&quot;
      .type = int(value_min=1)
  }
  reflections
    .help = &quot;Parameters used by the reflection manager&quot;
  {
    reflections_per_degree = 100
      .help = &quot;The number of centroids per degree of the sweep to use in&quot;
              &quot;refinement.&quot;
      .type = float(value_min=0)
    minimum_sample_size = 1000
      .help = &quot;cutoff that determines whether subsetting of the input&quot;
              &quot;reflection list is done&quot;
      .type = int
    maximum_sample_size = None
      .help = &quot;The maximum number of reflections to use in refinement.&quot;
              &quot;Overrides reflections_per_degree if that produces a larger&quot;
              &quot;sample size.&quot;
      .type = int(value_min=1)
    use_all_reflections = False
      .help = &quot;Override reflections_per_degree and use all available centroids&quot;
              &quot;in refinement.&quot;
      .type = bool
    random_seed = 42
      .help = &quot;Random seed to use when sampling to create a working set of&quot;
              &quot;reflections. May be int or None.&quot;
      .type = int
      .expert_level = 1
    close_to_spindle_cutoff = 0.05
      .help = &quot;The inclusion criterion currently uses the volume of the&quot;
              &quot;parallelepiped formed by the spindle axis, the incident beam&quot;
              &quot;and the scattered beam. If this is lower than some value then&quot;
              &quot;the reflection is excluded from refinement. In detector space,&quot;
              &quot;these are the reflections located close to the rotation axis.&quot;
      .type = float(value_min=0)
      .expert_level = 1
    block_width = 1.0
      .help = &quot;Width of a reflection 'block' (in degrees) determining how&quot;
              &quot;fine- grained the model used for scan-varying prediction during&quot;
              &quot;refinement is. Currently only has any effect if the crystal&quot;
              &quot;parameterisation is set to use UB_model_per=block&quot;
      .type = float(value_min=0)
      .expert_level = 1
    weighting_strategy
      .help = &quot;Parameters to configure weighting strategy overrides&quot;
      .expert_level = 1
    {
      override = statistical stills constant
        .help = &quot;selection of a strategy to override default weighting&quot;
                &quot;behaviour&quot;
        .type = choice
      delpsi_constant = 10000
        .help = &quot;used by the stills strategy to choose absolute weight value&quot;
                &quot;for the angular distance from Ewald sphere term of the target&quot;
                &quot;function, whilst the X and Y parts use statistical weights&quot;
        .type = float(value_min=0)
      constants = 1.0 1.0 1.0
        .help = &quot;constant weights for three parts of the target function,&quot;
                &quot;whether the case is for stills or scans. The default gives&quot;
                &quot;unit weighting.&quot;
        .type = floats(size=3, value_min=0)
    }
    outlier
      .help = &quot;Outlier rejection after initial reflection prediction.&quot;
    {
      algorithm = null *auto mcd tukey sauter_poon
        .help = &quot;Outlier rejection algorithm. If auto is selected, the&quot;
                &quot;algorithm is chosen automatically&quot;
        .type = choice
      minimum_number_of_reflections = 20
        .help = &quot;The minimum number of input observations per outlier&quot;
                &quot;rejection job below which all reflections in the job will be&quot;
                &quot;rejected as potential outliers.&quot;
        .type = int(value_min=0)
      separate_experiments = True
        .help = &quot;If true, outlier rejection will be performed on each&quot;
                &quot;experiment separately. Otherwise, the data from all&quot;
                &quot;experiments will be combined for outlier rejection.&quot;
        .type = bool
      separate_panels = True
        .help = &quot;If true, outlier rejection will be performed separately for&quot;
                &quot;each panel of a multi-panel detector model. Otherwise data&quot;
                &quot;from across all panels will be combined for outlier&quot;
                &quot;rejection.&quot;
        .type = bool
      tukey
        .help = &quot;Options for the tukey outlier rejector&quot;
        .expert_level = 1
      {
        iqr_multiplier = 1.5
          .help = &quot;The IQR multiplier used to detect outliers. A value of 1.5&quot;
                  &quot;gives Tukey's rule for outlier detection&quot;
          .type = float(value_min=0)
      }
      mcd
        .help = &quot;Options for the mcd outlier rejector, which uses an algorithm&quot;
                &quot;based on FAST-MCD by Rousseeuw and van Driessen. See&quot;
                &quot;doi.org/10.1080/00401706.1999.10485670.&quot;
        .expert_level = 1
      {
        alpha = 0.5
          .help = &quot;Decimal fraction controlling the size of subsets over which&quot;
                  &quot;the covariance matrix determinant is minimised.&quot;
          .type = float(value_min=0, value_max=1)
        max_n_groups = 5
          .help = &quot;The maximum number of groups to split the dataset into if&quot;
                  &quot;the dataset is 'large' (more observations than twice the&quot;
                  &quot;min_group_size).&quot;
          .type = int(value_min=1)
        min_group_size = 300
          .help = &quot;The smallest sub-dataset size when splitting the dataset&quot;
                  &quot;into a number of groups, maximally max_n_groups.&quot;
          .type = int(value_min=100)
        n_trials = 500
          .help = &quot;The number of samples used for initial estimates to seed&quot;
                  &quot;the search within each sub-dataset.&quot;
          .type = int(value_min=1)
        k1 = 2
          .help = &quot;The number of concentration steps to take after initial&quot;
                  &quot;estimates.&quot;
          .type = int(value_min=1)
        k2 = 2
          .help = &quot;If the dataset is 'large', the number of concentration&quot;
                  &quot;steps to take after applying the best subset estimates to&quot;
                  &quot;the merged group.&quot;
          .type = int(value_min=1)
        k3 = 100
          .help = &quot;If the dataset is 'small', the number of concentration&quot;
                  &quot;steps to take after selecting the best of the initial&quot;
                  &quot;estimates, applied to the whole dataset.&quot;
          .type = int(value_min=1)
        threshold_probability = 0.975
          .help = &quot;Quantile probability from the Chi-squared distribution with&quot;
                  &quot;number of degrees of freedom equal to the number of&quot;
                  &quot;dimensions of the data data (e.g. 3 for X, Y and Phi&quot;
                  &quot;residuals). Observations whose robust Mahalanobis distances&quot;
                  &quot;are larger than the obtained quantile will be flagged as&quot;
                  &quot;outliers.&quot;
          .type = float(value_min=0, value_max=1)
      }
      sauter_poon
        .help = &quot;Options for the outlier rejector described in Sauter &amp; Poon&quot;
                &quot;(2010) (<a class="reference external" href="http://dx.doi.org/10.1107/S0021889810010782">http://dx.doi.org/10.1107/S0021889810010782</a>)&quot;
        .expert_level = 1
      {
        px_sz = Auto
          .help = &quot;X, Y pixel size in mm. If Auto, this will be taken from the&quot;
                  &quot;first panel of the first experiment.&quot;
          .type = floats(size=2, value_min=0.001)
        verbose = False
          .help = &quot;Verbose output.&quot;
          .type = bool
          .multiple = False
        pdf = None
          .help = &quot;Output file name for making graphs of <a href="#id1"><span class="problematic" id="id2">|dr|</span></a> vs spot number&quot;
                  &quot;and dy vs dx.&quot;
          .type = str
          .multiple = False
      }
    }
  }
}
integration {
  mp {
    method = *multiprocessing sge lsf pbs
      .help = &quot;The multiprocessing method to use&quot;
      .type = choice
    nproc = 1
      .help = &quot;The number of processes to use.&quot;
      .type = int(value_min=1)
    nthreads = 1
      .help = &quot;The number of local threads to use for openmp.&quot;
      .type = int(value_min=1)
  }
  lookup
    .help = &quot;Parameters specifying lookup file path&quot;
  {
    mask = None
      .help = &quot;The path to the mask file.&quot;
      .type = str
  }
  block {
    size = auto
      .help = &quot;The block size in rotation angle (degrees).&quot;
      .type = float
    units = *degrees radians frames
      .help = &quot;The units of the block size&quot;
      .type = choice
    threshold = 0.99
      .help = &quot;For block size auto the block size is calculated by sorting&quot;
              &quot;reflections by the number of frames they cover and then&quot;
              &quot;selecting the block size to be 2*nframes[threshold] such that&quot;
              &quot;100*threshold % of reflections are guarenteed to be fully&quot;
              &quot;contained in 1 block&quot;
      .type = float(value_min=0, value_max=1)
    force = False
      .help = &quot;If the number of processors is 1 and force is False, then the&quot;
              &quot;number of blocks may be set to 1. If force is True then the&quot;
              &quot;block size is always calculated.&quot;
      .type = bool
    max_memory_usage = 0.75
      .help = &quot;The maximum percentage of total physical memory to use for&quot;
              &quot;allocating shoebox arrays.&quot;
      .type = float(value_min=0, value_max=1)
  }
  debug {
    reference {
      output = False
        .help = &quot;Save the reference profiles&quot;
        .type = bool
    }
    during = modelling *integration
      .help = &quot;Do debugging during modelling or integration&quot;
      .type = choice
    output = False
      .help = &quot;Save shoeboxes after each processing task.&quot;
      .type = bool
    select = None
      .help = &quot;A string specifying the selection. The string should be of the&quot;
              &quot;form: select=${COLUMN}[&lt;<a href="#id3"><span class="problematic" id="id4">|&lt;=|==|</span></a>!=|&gt;=|&gt;]${VALUE}. In addition to&quot;
              &quot;the items in the reflection table, the following implicit&quot;
              &quot;columns are defined if the necessary data is there: &quot;
              &quot;intensity.sum.i_over_sigma  intensity.prf.i_over_sigma&quot;
      .type = reflection_table_selector
    split_experiments = True
      .help = &quot;Split shoeboxes into different files&quot;
      .type = bool
  }
  profile {
    fitting = True
      .help = &quot;Use profile fitting if available&quot;
      .type = bool
    validation {
      number_of_partitions = 1
        .help = &quot;The number of subsamples to take from the reference spots. If&quot;
                &quot;the value is 1, then no validation is performed.&quot;
        .type = int(value_min=1)
      min_partition_size = 100
        .help = &quot;The minimum number of spots to use in each subsample.&quot;
        .type = int(value_min=1)
    }
  }
  filter
    .expert_level = 1
  {
    min_zeta = 0.05
      .help = &quot;Filter the reflections by the value of zeta. A value of less&quot;
              &quot;than or equal to zero indicates that this will not be used. A&quot;
              &quot;positive value is used as the minimum permissable value.&quot;
      .type = float(value_min=0, value_max=1)
    max_shoebox_overlap = 1.0
      .help = &quot;Filter reflections whose shoeboxes are overlapped by greater&quot;
              &quot;than the requested amount. Note that this is not the percentage&quot;
              &quot;of the peak that is overlapped but rather the percentage of the&quot;
              &quot;shoebox (background and foreground). This can be useful when&quot;
              &quot;the detector is too close and many overlapping reflections are&quot;
              &quot;predicted at high resolution causing memory issues.&quot;
      .type = float(value_min=0, value_max=1)
    powder {
      water_ice {
        unit_cell = 4.498,4.498,7.338,90,90,120
          .help = &quot;The unit cell to generate d_spacings for ice rings.&quot;
          .type = unit_cell
        space_group = 194
          .help = &quot;The space group used to generate d_spacings for ice rings.&quot;
          .type = space_group
        d_min = 1
          .help = &quot;The minimum resolution to filter ice rings&quot;
          .type = float(value_min=0)
        width = 0.06
          .help = &quot;The width of an ice ring (in d-spacing).&quot;
          .type = float(value_min=0)
      }
      apply = *none water_ice
        .help = &quot;The power ring filters to apply&quot;
        .type = choice(multi=True)
    }
  }
  background
    .help = &quot;  I n t e r f a c e   f o r   b a c k g r o u n d   a l g o r i t&quot;
            &quot;h m s .  &quot;
  {
    algorithm = *simple null glm
      .help = &quot;The choice of algorithm&quot;
      .type = choice
    simple
      .help = &quot;An extension class implementing XDS background subtraction.&quot;
    {
      outlier
        .help = &quot;Outlier rejection prior to background fit&quot;
      {
        algorithm = null *nsigma truncated normal mosflm tukey
          .help = &quot;The outlier rejection algorithm.&quot;
          .type = choice
        nsigma
          .help = &quot;Parameters for nsigma outlier rejector&quot;
          .expert_level = 1
        {
          lower = 3
            .help = &quot;Lower n sigma&quot;
            .type = float
          upper = 3
            .help = &quot;Upper n sigma&quot;
            .type = float
        }
        truncated
          .help = &quot;Parameters for truncated outlier rejector&quot;
          .expert_level = 1
        {
          lower = 0.01
            .help = &quot;Lower bound&quot;
            .type = float
          upper = 0.01
            .help = &quot;Upper bound&quot;
            .type = float
        }
        normal
          .help = &quot;Parameters for normal outlier rejector&quot;
          .expert_level = 1
        {
          min_pixels = 10
            .help = &quot;The minimum number of pixels to use in calculating the&quot;
                    &quot;background intensity.&quot;
            .type = int
        }
        mosflm
          .help = &quot;Parameters for mosflm-like outlier rejector. This algorithm&quot;
                  &quot;is mainly used in conjunction with a linear 2d background.&quot;
          .expert_level = 1
        {
          fraction = 1.0
            .help = &quot;The fraction of pixels to use in determining the initial&quot;
                    &quot;plane used for outlier rejection.&quot;
            .type = float
          n_sigma = 4.0
            .help = &quot;The number of standard deviations above the threshold&quot;
                    &quot;plane to use in rejecting outliers from background&quot;
                    &quot;calculation.&quot;
            .type = float
        }
        tukey
          .help = &quot;Parameters for tukey outlier rejector&quot;
          .expert_level = 1
        {
          lower = 1.5
            .help = &quot;Lower IQR multiplier&quot;
            .type = float
          upper = 1.5
            .help = &quot;Upper IQR multiplier&quot;
            .type = float
        }
      }
      model
        .help = &quot;Background model&quot;
      {
        algorithm = constant2d *constant3d linear2d linear3d
          .help = &quot;The choice of background model&quot;
          .type = choice
      }
    }
    glm
      .help = &quot;An extension class implementing XDS background subtraction.&quot;
    {
      robust {
        tuning_constant = 1.345
          .help = &quot;The tuning constant for robust estimation&quot;
          .type = float
      }
      model {
        algorithm = constant2d *constant3d loglinear2d loglinear3d
          .help = &quot;The background model to fit&quot;
          .type = choice
      }
    }
  }
  centroid
    .help = &quot;  I n t e r f a c e   f o r   c e n t r o i d   a l g o r i t h m&quot;
            &quot;s .  &quot;
  {
    algorithm = *simple
      .help = &quot;The choice of algorithm&quot;
      .type = choice
  }
}
profile
  .help = &quot;
     T h e   i n t e r f a c e   d e f i n i t i o n   f o r   a  &quot;
          &quot;p r o f i l e   m o d e l . 
 
    &quot;
{
  algorithm = gaussian_rs *gaussian_rs
    .help = &quot;The choice of algorithm&quot;
    .type = choice
  gaussian_rs
    .help = &quot;An extension class implementing a reciprocal space gaussian&quot;
            &quot;profile model.&quot;
  {
    scan_varying = False
      .help = &quot;Calculate a scan varying model&quot;
      .type = bool
    min_spots = 100
      .help = &quot;The minimum number of spots needed to do the profile modelling&quot;
      .type = int(value_min=0)
    filter {
      min_zeta = 0.05
        .help = &quot;Filter reflections by min zeta&quot;
        .type = float
    }
    fitting {
      scan_step = 5
        .help = &quot;Space between profiles in degrees&quot;
        .type = float
      grid_size = 5
        .help = &quot;The size of the profile grid.&quot;
        .type = int
      threshold = 0.02
        .help = &quot;The threshold to use in reference profile&quot;
        .type = float
      grid_method = single *regular_grid circular_grid
        .help = &quot;Select the profile grid method&quot;
        .type = choice
      fit_method = *reciprocal_space detector_space
        .help = &quot;The fitting method&quot;
        .type = choice
    }
  }
  gaussian_rs
    .help = &quot;An extension class implementing a reciprocal space gaussian&quot;
            &quot;profile model.&quot;
  {
    scan_varying = False
      .help = &quot;Calculate a scan varying model&quot;
      .type = bool
    min_spots = 100
      .help = &quot;The minimum number of spots needed to do the profile modelling&quot;
      .type = int(value_min=0)
    filter {
      min_zeta = 0.05
        .help = &quot;Filter reflections by min zeta&quot;
        .type = float
    }
    fitting {
      scan_step = 5
        .help = &quot;Space between profiles in degrees&quot;
        .type = float
      grid_size = 5
        .help = &quot;The size of the profile grid.&quot;
        .type = int
      threshold = 0.02
        .help = &quot;The threshold to use in reference profile&quot;
        .type = float
      grid_method = single *regular_grid circular_grid
        .help = &quot;Select the profile grid method&quot;
        .type = choice
      fit_method = *reciprocal_space detector_space
        .help = &quot;The fitting method&quot;
        .type = choice
    }
  }
}
prediction {
  d_min = None
    .help = &quot;The maximum resolution limit&quot;
    .type = float
  d_max = None
    .help = &quot;The minimum resolution limit&quot;
    .type = float
  margin = 1
    .help = &quot;The margin to use to scan varying prediction&quot;
    .type = int
  force_static = False
    .help = &quot;For scan-varying prediction for scan-static&quot;
    .type = bool
}

</pre>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">DIALS</a></h1>



<p class="blurb">Diffraction Integration for Advanced Light Sources</p>




<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../links.html">Links</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>

  </body>
</html>