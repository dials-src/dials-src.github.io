
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dials.refine &mdash; DIALS  documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/button.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/dials-styles.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/dials-styles.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/dials_icon.png"/>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="DIALS  documentation" href="../../index.html" />
    <link rel="up" title="Program documentation" href="index.html" />
    <link rel="next" title="dials.integrate" href="dials_integrate.html" />
    <link rel="prev" title="dials.reindex" href="dials_reindex.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body>
  <div class="logoheader container">
  <a href="../../index.html">
  <img class="logoheader" alt="DIALS" src="../../_static/dials_header.png" />
  </a>
  </div>
  


  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="dials-refine">
<h1>dials.refine<a class="headerlink" href="#dials-refine" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Refine the diffraction geometry of input experiments against the input indexed
reflections. For rotation scans, the model may be either static (the same for
all reflections) or scan-varying (dependent on image number in the scan).
Other basic parameters include control over output filenames, fixing of
certain parameters of each model and options that control the number of
reflections used in refinement.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre>dials.refine experiments.json indexed.pickle

dials.refine experiments.json indexed.pickle scan_varying=True
</pre></div>
</div>
</div>
<div class="section" id="basic-parameters">
<h2>Basic parameters<a class="headerlink" href="#basic-parameters" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">
output {
  experiments = refined_experiments.json
  reflections = refined.pickle
}
refinement {
  verbosity = 1
  parameterisation {
    auto_reduction {
      min_nref_per_parameter = 5
      action = *fail fix remove
    }
    beam {
      fix = all *in_spindle_plane out_spindle_plane *wavelength
    }
    crystal {
      fix = all cell orientation
      scan_varying = False
    }
    detector {
      fix = all position orientation
    }
  }
  reflections {
    reflections_per_degree = 100
    minimum_sample_size = 1000
    maximum_sample_size = None
    use_all_reflections = False
    outlier {
      algorithm = null *auto mcd tukey sauter_poon
      minimum_number_of_reflections = 20
      separate_experiments = True
      separate_panels = True
    }
  }
}

</pre>
</div>
<div class="section" id="full-parameter-definitions">
<h2>Full parameter definitions<a class="headerlink" href="#full-parameter-definitions" title="Permalink to this headline">¶</a></h2>
<pre class="literal-block">
output {
  experiments = refined_experiments.json
    .help = &quot;The filename for refined experimental models&quot;
    .type = str
  reflections = refined.pickle
    .help = &quot;The filename for reflections with updated predictions&quot;
    .type = str
  matches = None
    .help = &quot;The filename for output of the reflection table for reflections&quot;
            &quot;used in refinement, containing extra columns used internally.&quot;
            &quot;Intended for debugging purposes only&quot;
    .type = str
    .expert_level = 2
  centroids = None
    .help = &quot;The filename for the table of centroids at the end of refinement&quot;
    .type = str
    .expert_level = 1
  parameter_table = None
    .help = &quot;The filename for the table of scan varying parameter values&quot;
    .type = str
    .expert_level = 1
  correlation_plot
    .expert_level = 1
  {
    filename = None
      .help = &quot;The base filename for output of plots of parameter&quot;
              &quot;correlations. A file extension may be added to control the type&quot;
              &quot;of output file, if it is one of matplotlib's supported types&quot;
      .type = str
    save_matrix = False
      .help = &quot;Save the matrix and column labels in a pickle file for later&quot;
              &quot;inspection, replotting etc.&quot;
      .type = bool
    col_select = None
      .help = &quot;Specific columns to include in the plots of parameter&quot;
              &quot;correlations, either specifed by parameter name or column&quot;
              &quot;number. Defaults to all columns. This option is useful when&quot;
              &quot;there is a large number of parameters&quot;
      .type = str
      .multiple = True
    steps = None
      .help = &quot;Steps for which to make correlation plots. By default only the&quot;
              &quot;final step is plotted. Uses zero-based numbering, so the first&quot;
              &quot;step is numbered 0.&quot;
      .type = ints(value_min=0)
  }
  history = None
    .help = &quot;The filename for output of the refinement history pickle&quot;
    .type = str
    .expert_level = 1
}
refinement
  .help = &quot;Parameters to configure the refinement&quot;
{
  mp
    .expert_level = 1
  {
    nproc = 1
      .help = &quot;The number of processes to use. Only applicable to certain&quot;
              &quot;choices of refinement engine!&quot;
      .type = int(value_min=1)
  }
  verbosity = 1
    .help = &quot;verbosity level&quot;
    .type = int(value_min=0)
  parameterisation
    .help = &quot;Parameters to control the parameterisation of experimental models&quot;
  {
    auto_reduction
      .help = &quot;determine behaviour when there are too few reflections to&quot;
              &quot;reasonably produce a full parameterisation of the experiment&quot;
              &quot;list&quot;
    {
      min_nref_per_parameter = 5
        .help = &quot;the smallest number of reflections per parameter for a model&quot;
                &quot;parameterisation below which the parameterisation will not be&quot;
                &quot;made in full, but the action described below will be&quot;
                &quot;triggered.&quot;
        .type = int(value_min=1)
      action = *fail fix remove
        .help = &quot;action to take if there are too few reflections across the&quot;
                &quot;experiments related to a particular model parameterisation.&quot;
                &quot;If fail, an exception will be raised and refinement will not&quot;
                &quot;proceed. If fix, refinement will continue but with the&quot;
                &quot;parameters relating to that model remaining fixed at their&quot;
                &quot;initial values. If remove, parameters relating to that model&quot;
                &quot;will be fixed, and in addition all reflections related to&quot;
                &quot;that parameterisation will be removed. This will therefore&quot;
                &quot;remove this reflections from other parameterisations of the&quot;
                &quot;global model too. For example, if a crystal model could not&quot;
                &quot;be parameterised it will be excised completely and not&quot;
                &quot;contribute to the joint refinement of the detector and beam.&quot;
                &quot;In the fix mode, reflections emanating from that crystal will&quot;
                &quot;still form residuals and will contribute to detector and beam&quot;
                &quot;refinement.&quot;
        .type = choice
    }
    beam
      .help = &quot;beam parameters&quot;
    {
      fix = all *in_spindle_plane out_spindle_plane *wavelength
        .help = &quot;Whether to fix beam parameters. By default, in_spindle_plane&quot;
                &quot;is selected, and one of the two parameters is fixed. If a&quot;
                &quot;goniometer is present this leads to the beam orientation&quot;
                &quot;being restricted to a direction in the initial spindle-beam&quot;
                &quot;plane. Wavelength is also fixed by default, to allow&quot;
                &quot;refinement of the unit cell volume.&quot;
        .type = choice(multi=True)
      fix_list = None
        .help = &quot;Fix specified parameters by a list of indices&quot;
        .type = ints(value_min=0)
        .expert_level = 1
    }
    crystal
      .help = &quot;crystal parameters&quot;
    {
      fix = all cell orientation
        .help = &quot;Fix crystal parameters&quot;
        .type = choice
      cell_fix_list = None
        .help = &quot;Fix specified parameters by a list of indices&quot;
        .type = ints(value_min=0)
        .expert_level = 1
      orientation_fix_list = None
        .help = &quot;Fix specified parameters by a list of indices&quot;
        .type = ints(value_min=0)
        .expert_level = 1
      scan_varying = False
        .help = &quot;Parameterise the crystal to vary during the scan&quot;
        .type = bool
      num_intervals = *fixed_width absolute
        .help = &quot;Choose the way to determine the number of intervals for scan-&quot;
                &quot;varying refinement&quot;
        .type = choice
        .expert_level = 1
      interval_width_degrees = 36.0
        .help = &quot;Width of scan between checkpoints in degrees&quot;
        .type = float(value_min=0)
        .expert_level = 1
      absolute_num_intervals = 5
        .help = &quot;Number of intervals between checkpoints if scan_varying&quot;
                &quot;refinement is requested&quot;
        .type = int(value_min=1)
        .expert_level = 1
      UB_model_per = reflection image *block
        .help = &quot;Compose a new crystal model either every reflection (slow),&quot;
                &quot;every image (faster, less accurate) or within blocks of a&quot;
                &quot;width specified in the reflections parameters. When this&quot;
                &quot;block width is larger than the image width the result is&quot;
                &quot;faster again, with another trade-off in accuracy&quot;
        .type = choice
        .expert_level = 1
    }
    detector
      .help = &quot;detector parameters&quot;
    {
      panels = *automatic single multiple hierarchical
        .help = &quot;Select appropriate detector parameterisation. Both the single&quot;
                &quot;and multiple panel detector options treat the whole detector&quot;
                &quot;as a rigid body. The hierarchical parameterisation treats&quot;
                &quot;groups of panels as separate rigid bodies.&quot;
        .type = choice
        .expert_level = 1
      hierarchy_level = 0
        .help = &quot;Level of the detector hierarchy (starting from the root at 0)&quot;
                &quot;at which to determine panel groups to parameterise&quot;
                &quot;independently&quot;
        .type = int(value_min=0)
        .expert_level = 1
      fix = all position orientation
        .help = &quot;Fix detector parameters. The translational parameters&quot;
                &quot;(position) may be set separately to the orientation.&quot;
        .type = choice
      fix_list = None
        .help = &quot;Fix specified parameters by a list of indices&quot;
        .type = ints(value_min=0)
        .expert_level = 1
    }
    sparse = Auto
      .help = &quot;Calculate gradients using sparse data structures.&quot;
      .type = bool
      .expert_level = 1
    treat_single_image_as_still = False
      .help = &quot;Set this to True to treat a single image scan with a non zero&quot;
              &quot;oscillation width as a still&quot;
      .type = bool
      .expert_level = 1
  }
  refinery
    .help = &quot;Parameters to configure the refinery&quot;
    .expert_level = 1
  {
    engine = SimpleLBFGS LBFGScurvs GaussNewton *LevMar
      .help = &quot;The minimisation engine to use&quot;
      .type = choice
    track_step = False
      .help = &quot;Record parameter shifts history in the refinement journal, if&quot;
              &quot;the engine supports it.&quot;
      .type = bool
    track_gradient = False
      .help = &quot;Record parameter gradients history in the refinement journal,&quot;
              &quot;if the engine supports it.&quot;
      .type = bool
    track_parameter_correlation = False
      .help = &quot;Record correlation matrix between columns of the Jacobian for&quot;
              &quot;each step of refinement.&quot;
      .type = bool
    track_out_of_sample_rmsd = False
      .help = &quot;Record RMSDs calculated using the refined experiments with&quot;
              &quot;reflections not used in refinement at each step. Only valid if&quot;
              &quot;a subset of input reflections was taken for refinement&quot;
      .type = bool
    log = None
      .help = &quot;Filename for an optional log that a minimisation engine may use&quot;
              &quot;to write additional information&quot;
      .type = path
    max_iterations = None
      .help = &quot;Maximum number of iterations in refinement before termination.&quot;
              &quot;None implies the engine supplies its own default.&quot;
      .type = int(value_min=1)
  }
  target
    .help = &quot;Parameters to configure the target function&quot;
    .expert_level = 1
  {
    rmsd_cutoff = *fraction_of_bin_size absolute
      .help = &quot;Method to choose rmsd cutoffs. This is currently either as a&quot;
              &quot;fraction of the discrete units of the spot positional data,&quot;
              &quot;i.e. (pixel width, pixel height, image thickness in phi), or a&quot;
              &quot;tuple of absolute values to use as the cutoffs&quot;
      .type = choice
    bin_size_fraction = 0.2
      .help = &quot;Cut off in the natural discrete units of positional data, viz.,&quot;
              &quot;(pixel width, pixel height, image thickness in phi) to use to&quot;
              &quot;determine when the RMSD target is achieved. Only used if&quot;
              &quot;rmsd_cutoff = fraction_of_bin_size.&quot;
      .type = float(value_min=0)
    absolute_cutoffs = None
      .help = &quot;Absolute Values for the RMSD target achieved cutoffs in X, Y&quot;
              &quot;and Phi. The units are (mm, mm, rad).&quot;
      .type = floats(size=3, value_min=0)
    gradient_calculation_blocksize = None
      .help = &quot;Maximum number of reflections to use for gradient calculation.&quot;
              &quot;If there are more reflections than this in the manager then the&quot;
              &quot;minimiser must do the full calculation in blocks.&quot;
      .type = int(value_min=1)
  }
  reflections
    .help = &quot;Parameters used by the reflection manager&quot;
  {
    reflections_per_degree = 100
      .help = &quot;The number of centroids per degree of the sweep to use in&quot;
              &quot;refinement.&quot;
      .type = float(value_min=0)
    minimum_sample_size = 1000
      .help = &quot;cutoff that determines whether subsetting of the input&quot;
              &quot;reflection list is done&quot;
      .type = int
    maximum_sample_size = None
      .help = &quot;The maximum number of reflections to use in refinement.&quot;
              &quot;Overrides reflections_per_degree if that produces a larger&quot;
              &quot;sample size.&quot;
      .type = int(value_min=1)
    use_all_reflections = False
      .help = &quot;Override reflections_per_degree and use all available centroids&quot;
              &quot;in refinement.&quot;
      .type = bool
    random_seed = 42
      .help = &quot;Random seed to use when sampling to create a working set of&quot;
              &quot;reflections. May be int or None.&quot;
      .type = int
      .expert_level = 1
    close_to_spindle_cutoff = 0.05
      .help = &quot;The inclusion criterion currently uses the volume of the&quot;
              &quot;parallelepiped formed by the spindle axis, the incident beam&quot;
              &quot;and the scattered beam. If this is lower than some value then&quot;
              &quot;the reflection is excluded from refinement. In detector space,&quot;
              &quot;these are the reflections located close to the rotation axis.&quot;
      .type = float(value_min=0)
      .expert_level = 1
    block_width = 1.0
      .help = &quot;Width of a reflection 'block' (in degrees) determining how&quot;
              &quot;fine- grained the model used for scan-varying prediction during&quot;
              &quot;refinement is. Currently only has any effect if the crystal&quot;
              &quot;parameterisation is set to use UB_model_per=block&quot;
      .type = float(value_min=0)
      .expert_level = 1
    weighting_strategy
      .help = &quot;Parameters to configure weighting strategy overrides&quot;
      .expert_level = 1
    {
      override = statistical stills constant
        .help = &quot;selection of a strategy to override default weighting&quot;
                &quot;behaviour&quot;
        .type = choice
      delpsi_constant = 10000
        .help = &quot;used by the stills strategy to choose absolute weight value&quot;
                &quot;for the angular distance from Ewald sphere term of the target&quot;
                &quot;function, whilst the X and Y parts use statistical weights&quot;
        .type = float(value_min=0)
      constants = 1.0 1.0 1.0
        .help = &quot;constant weights for three parts of the target function,&quot;
                &quot;whether the case is for stills or scans. The default gives&quot;
                &quot;unit weighting.&quot;
        .type = floats(size=3, value_min=0)
    }
    outlier
      .help = &quot;Outlier rejection after initial reflection prediction.&quot;
    {
      algorithm = null *auto mcd tukey sauter_poon
        .help = &quot;Outlier rejection algorithm. If auto is selected, the&quot;
                &quot;algorithm is chosen automatically&quot;
        .type = choice
      minimum_number_of_reflections = 20
        .help = &quot;The minimum number of input observations per outlier&quot;
                &quot;rejection job below which all reflections in the job will be&quot;
                &quot;rejected as potential outliers.&quot;
        .type = int(value_min=0)
      separate_experiments = True
        .help = &quot;If true, outlier rejection will be performed on each&quot;
                &quot;experiment separately. Otherwise, the data from all&quot;
                &quot;experiments will be combined for outlier rejection.&quot;
        .type = bool
      separate_panels = True
        .help = &quot;If true, outlier rejection will be performed separately for&quot;
                &quot;each panel of a multi-panel detector model. Otherwise data&quot;
                &quot;from across all panels will be combined for outlier&quot;
                &quot;rejection.&quot;
        .type = bool
      tukey
        .help = &quot;Options for the tukey outlier rejector&quot;
        .expert_level = 1
      {
        iqr_multiplier = 1.5
          .help = &quot;The IQR multiplier used to detect outliers. A value of 1.5&quot;
                  &quot;gives Tukey's rule for outlier detection&quot;
          .type = float(value_min=0)
      }
      mcd
        .help = &quot;Options for the mcd outlier rejector, which uses an algorithm&quot;
                &quot;based on FAST-MCD by Rousseeuw and van Driessen. See&quot;
                &quot;doi.org/10.1080/00401706.1999.10485670.&quot;
        .expert_level = 1
      {
        alpha = 0.5
          .help = &quot;Decimal fraction controlling the size of subsets over which&quot;
                  &quot;the covariance matrix determinant is minimised.&quot;
          .type = float(value_min=0, value_max=1)
        max_n_groups = 5
          .help = &quot;The maximum number of groups to split the dataset into if&quot;
                  &quot;the dataset is 'large' (more observations than twice the&quot;
                  &quot;min_group_size).&quot;
          .type = int(value_min=1)
        min_group_size = 300
          .help = &quot;The smallest sub-dataset size when splitting the dataset&quot;
                  &quot;into a number of groups, maximally max_n_groups.&quot;
          .type = int(value_min=100)
        n_trials = 500
          .help = &quot;The number of samples used for initial estimates to seed&quot;
                  &quot;the search within each sub-dataset.&quot;
          .type = int(value_min=1)
        k1 = 2
          .help = &quot;The number of concentration steps to take after initial&quot;
                  &quot;estimates.&quot;
          .type = int(value_min=1)
        k2 = 2
          .help = &quot;If the dataset is 'large', the number of concentration&quot;
                  &quot;steps to take after applying the best subset estimates to&quot;
                  &quot;the merged group.&quot;
          .type = int(value_min=1)
        k3 = 100
          .help = &quot;If the dataset is 'small', the number of concentration&quot;
                  &quot;steps to take after selecting the best of the initial&quot;
                  &quot;estimates, applied to the whole dataset.&quot;
          .type = int(value_min=1)
        threshold_probability = 0.975
          .help = &quot;Quantile probability from the Chi-squared distribution with&quot;
                  &quot;number of degrees of freedom equal to the number of&quot;
                  &quot;dimensions of the data data (e.g. 3 for X, Y and Phi&quot;
                  &quot;residuals). Observations whose robust Mahalanobis distances&quot;
                  &quot;are larger than the obtained quantile will be flagged as&quot;
                  &quot;outliers.&quot;
          .type = float(value_min=0, value_max=1)
      }
      sauter_poon
        .help = &quot;Options for the outlier rejector described in Sauter &amp; Poon&quot;
                &quot;(2010) (<a class="reference external" href="http://dx.doi.org/10.1107/S0021889810010782">http://dx.doi.org/10.1107/S0021889810010782</a>)&quot;
        .expert_level = 1
      {
        px_sz = Auto
          .help = &quot;X, Y pixel size in mm. If Auto, this will be taken from the&quot;
                  &quot;first panel of the first experiment.&quot;
          .type = floats(size=2, value_min=0.001)
        verbose = False
          .help = &quot;Verbose output.&quot;
          .type = bool
          .multiple = False
        pdf = None
          .help = &quot;Output file name for making graphs of <a href="#id1"><span class="problematic" id="id2">|dr|</span></a> vs spot number&quot;
                  &quot;and dy vs dx.&quot;
          .type = str
          .multiple = False
      }
    }
  }
}

</pre>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">DIALS</a></h1>



<p class="blurb">Diffraction Integration for Advanced Light Sources</p>




<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../links.html">Links</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>

  </body>
</html>